<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 8 ­ Advanced Trees<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<A name=2></a><b>Learning Objectives </b><br>
§ Understand and be able to use the data structures <br>binary search trees, splay trees and B-trees<br>
§ Be able to understand, apply and develop <br>algorithms to handle the data structures above. <br>Including:<br>
§Access to keys in trees<br>
§Balancing trees<br>
§Adjusting trees<br>
2<br>
<hr>
<A name=3></a><b>Balanced Trees</b><br>
3<br>
<hr>
<A name=4></a><b>Remember...Analysis of binary search trees</b><br>
§ Search, delete and insert have the height of the tree as the <br>
worst case for running time.<br>
§ Search, delete and insert take <i>O(log n), </i>where <i>n </i>is the <br>
number of nodes in the tree, if the tree is close to perfectly <br>balanced.<br>
§ Otherwise, they can be as bad as <i>O(n)<br></i>§ <b>Problem</b>: insertion and deletion make the tree less <br>
balanced.<br>
§ <b>Solution</b>: keep the tree approximately balanced, without <br>
making insertion and deletion too expensive<br>
4<br>
<hr>
<A name=5></a><b>The importance of trees being balanced</b><br>
§ To access a node in a binary search tree, the path is visited <br>
from the root to the node.<br>
§ This means that the maximum number of nodes visited is <br>
equal to the height of the tree.<br>
§ In a perfectly balanced tree, this is log(n)+1.<br>
5<br>
<hr>
<A name=6></a><b>A not-so-balanced tree</b><br>
§ The maximum number of levels of a tree with <i>n </i>node is <i>n</i>.<br>
6<br>
<hr>
<A name=7></a><b>Should the tree be kept balanced?</b><br>
The <b>height <i>h </i>of the tree </b>will be between <b>log(<i>n</i>)+1 and <i>n</b></i>, <br>so the time complexity of access to the tree will be between <br>O(log n) and O(n)<br>
Ideally, the tree should be kept <b>perfectly balanced</b>, with <br><b><i>h </i>= log (<i>n</i>) + 1</b>. Doing this after insertion or deletion takes <br>O(n) time, which defeats the purpose of efficiency.<br>
Solution: keep the tree balanced enough to obtain O(log n) <br>height.<br>
7<br>
<hr>
<A name=8></a><b>Some approximate balance definitions</b><br>
<b>Weight-balanced trees</b>:<br>each node has 1/k &lt;= <i>size(right)/size(left) </i>&lt;= k<br><b>AVL trees </b>(height-balanced):<br>each node has  -1 &lt;= <i>height(right) - height(left) </i>&lt;= 1<br>
(AVL-balance)<br>
<b>Red-Black trees</b>: each node is either red or black, and no red <br>node can have a red child.<br>Each full path from the root contains the same number of <br>black nodes.<br>
8<br>
<hr>
<A name=9></a><b>Balancing Trees</b><br>
9<br>
<hr>
<A name=10></a><b>Tree Rotations</b><br>
§ Rotation is a basic operation in <br>
many tree re-balancing schemes<br>
§ Rotations keep the search tree <br>
structure<br>
§ Rotations can be applied <br>
anywhere in the tree<br>
10<br>
<hr>
<A name=11></a><b>Tree Rotation in Java</b><br>
public TreeNode rotateLeft(TreeNode oldRoot) {<br>
TreeNode newRoot = oldRoot.getRight();<br>if(newRoot != null){<br>
oldRoot.setRight(newRoot.getLeft());<br>newRoot.setLeft(oldRoot);<br>
}<br>
oldRoot<br>
newRoot<br>
return newRoot;<br>// needs to checked<br>// by caller<br>
A newRoot<br>
oldRoot<br>
C<br>
}<br>
11<br>
B<br>
C<br>
A<br>
B<br>
<hr>
<A name=12></a><b>Left and Right Tree Rotations</b><br>
§ Rotations can be applied in two directions<br>
12<br>
<hr>
<A name=13></a><b>Left Tree Rotation Example </b><br>
18<br>
17<br>
29<br>
15<br>
25<br>
36<br>
9<br>
16<br>
32<br>
13<br>
<hr>
<A name=14></a><b>Right Tree Rotation Example </b><br>
18<br>
17<br>
29<br>
15<br>
25<br>
36<br>
9<br>
16<br>
32<br>
14<br>
<hr>
<A name=15></a><b>Re-balancing an AVL tree</b><br>
If insertion invalidates the AVL condition (-1 &lt;= <i>height(right) - height(left) <br></i>&lt;= 1), use rotations to restore it:<br>§ For insertion, at most two O(1) rotations are required (but finding the <br>
position still takes O(log n) )<br>
§ Deletions may require rotating any nodes in the path to the changed <br>
node, O(log n)<br>
§ No re-balancing at lookup-only access<br>
15<br>
<hr>
<A name=16></a><b>Rebalancing by Single Rotation</b><br>
If root has AVL-balance &lt; -1 or AVL-balance &gt; 1 and<br>child balance on higher subtree side has same sign or is 0<br>
+2<br>
0<br>
s<br>
t<br>
+1<br>
0<br>
y<br>t<br>
s<br>
x<br>u<br>
A<br>
x<br>
u<br>
B<br>
A<br>
B<br>
C<br>
16<br>
C<br>
<hr>
<A name=17></a><b>Rebalancing by Single Rotation Example </b><br>
18<br>
17<br>
29<br>
15<br>
9<br>
16<br>
17<br>
<hr>
<A name=18></a><b>Rebalancing by Double Rotation</b><br>
If root has AVL-balance &lt; -1 or AVL-balance &gt; 1 and<br>higher subtree side child AVL-balance has opposite sign<br>
+2<br>
+2<br>
0<br>
s<br>
x<br>s<br>
t<br>
-1<br>
+1<br>
u<br>
y<br>t<br>
s<br>
x<br>u<br>
A<br>
A<br>
0<br>
0<br>
t<br>
z<br>u<br>
D<br>
A<br>
B<br>
C<br>
D<br>
B<br>
18<br>
B<br>
C<br>
C<br>
D<br>
C<br>
<hr>
<A name=19></a><b>Rebalancing by Double Rotation Example </b><br>
18<br>
7<br>
29<br>
15<br>
9<br>
16<br>
19<br>
<hr>
<A name=20></a><b>AVL Tree Rebalancing Animation</b><br>
§ Inserting 12, 23, 200, 17, 15, 20, 18<br>§ Then deleting 15, etc.<br>
AVL Tree<br>
20<br>
<hr>
<A name=21></a><b>Splay Trees</b><br>
21<br>
<hr>
<A name=22></a><b>Splay Trees</b><br>
§ A splay tree rearranges itself after each access<br>§ Moves the accessed node to root (splay operation)<br>§ Frequently accessed keys get closer to the root<br>§ No need for additional information to be stored<br>
22<br>
<hr>
<A name=23></a><b>Splay step operations</b><br>
There are three cases (plus a symmetric one), and maximally two rotations <br>per splay:<br>§ Until accessed node is the root:<br>§ If the accessed node's parent is the root (zig), rotate the accessed node <br>
up.<br>
§ If the accessed node is a left child and its parent is a left child as well <br>
(zig-zig), rotate the parent up and then rotate the accessed node up.*<br>
§ Otherwise (zig-zag), rotate to the accessed node up twice (standard <br>
double rotation).<br>
* Also applies to right child and right child<br>
23<br>
<hr>
<A name=24></a><b>An example splay operation </b><br>
After accessing 6, repeatedly apply splay(6):<br>
1<br>
2<br>
3<br>
4<br>
5<br>
zig-zig<br>
6<br>
24<br>
<hr>
<A name=25></a><b>Example splay (cntd.)</b><br>
6<br>
1<br>
1<br>
6<br>
3<br>
3<br>
2<br>
5<br>
2<br>
5<br>
4<br>
4<br>
zig<br>
After the third splay, 6 is at the <br>root of the tree.<br>
25<br>
<hr>
<A name=26></a><b>Example splay zig zag</b><br>
After accessing 4, repeatedly apply splay(4):<br>
6<br>
6<br>
1<br>
1<br>
3<br>
4<br>
2<br>
5<br>
3<br>
5<br>
4<br>
2<br>
zig-zag<br>
zig-zag<br>
26<br>
<hr>
<A name=27></a><b>Example splay zig zag (cntd.)</b><br>
4<br>
1<br>
6<br>
3<br>
5<br>
2<br>
After the second splay, 4 is at the root of the tree. <br>Note that 6 is still closer to the root than initially.<br>
27<br>
<hr>
<A name=28></a><b>Splay trees are self-organising</b><br>
There are three cases (plus a symmetric one), and maximally two rotations <br>per splay:<br>§ Until accessed node is the root:<br>§ If the accessed node's parent is the root (zig), rotate the accessed node <br>
up.<br>
§ If the accessed node is a left child and its parent is a left child as well <br>
(zig-zig), rotate the parent up and then rotate the accessed node up.*<br>
§ Otherwise (zig-zag), rotate to the accessed node up twice (standard <br>
double rotation).<br>
* Also applies to right child and right child<br>
28<br>
<hr>
<A name=29></a><b>Splay Tree Animation</b><br>
§ Inserting 1, 2, 3, 4, 5, 6<br>§ Then finding 1, 4, etc.<br>§ Then deleting ...<br>
Splay tree<br>
29<br>
<hr>
<A name=30></a><b>Multi-Way Search Trees</b><br>
30<br>
<hr>
<A name=31></a><b>Multi-way search trees</b><br>
Each node has <i>m </i>subtrees, interleaved with <i>m-1 </i>keys stored in ascending <br>order<br>
All keys in subtrees to the left of key <i>k </i>are smaller than <i>k<br></i>All keys in subtrees to the right of key <i>k </i>are greater<br>Large <i>m </i>is useful for external storage (hard disk)<br>Small <i>m </i>is better for internal storage (RAM)<br>... and binary search trees are multi-way trees with <i>m = 2</i><br>
31<br>
<hr>
<A name=32></a><b>B-Trees</b><br>
A B-tree of order <i>m </i>is a multi-way search tree for which:<br>§ the root has at least one key<br>§ every non-root node has <i>k </i>subtrees and <i>k-1 </i>keys with  <i>m/2 + 1 &lt;= k &lt;= m<br></i>§ leaves have all subtrees empty<br>§ non-leaf nodes have non-empty subtrees<br>§ all leaves are at the same level<br>The last condition guarantees that B-trees are approximately balanced.<br>For hard disk storage, one node is one HD block. <br>
32<br>
<hr>
<A name=33></a><b>A B-tree of order 4 and height 3</b><br>
50<br>
10 23 32<br>
68 80<br>
6 8<br>
16 18<br>
24 27<br>
34 38 45<br>
54 62<br>
70 76<br>
81 92<br>
33<br>
<hr>
<A name=34></a><b>Insertion into a B-tree</b><br>
Always insert new keys into a leaf<br>If the node overflows, split it:<br>
§ where k is the middle key of the overflowed node<br>§ if the parent node overflows, repeat<br>§ it the root overflows, create a new root on top and split<br>
34<br>
<hr>
<A name=35></a><b>Insertion into a B-tree Example</b><br>
Insert 83 then 90<br>
50<br>
10 23 32<br>
68 80<br>
6 8<br>
16 18<br>
24 27<br>
34 38 45<br>
54 62<br>
70 76<br>
81 92<br>
35<br>
<hr>
<A name=36></a><b>Insertion into a B-tree Example (cntd.)</b><br>
Insert 83 (then 90) <br>
50<br>
10 23 32<br>
68 80<br>
6 8<br>
16 18<br>
24 27<br>
34 38 45<br>
54 62<br>
70 76<br>
81 83 92<br>
36<br>
<hr>
<A name=37></a><b>Insertion into a B-tree Example (cntd.)</b><br>
Insert 90<br>
50<br>
10 23 32<br>
68 80 83<br>
6 8<br>
16 18<br>
24 27<br>
34 38 45 54 62<br>
70 76<br>
81<br>
90 92<br>
37<br>
<hr>
<A name=38></a><b>Deletion from a B-tree</b><br>
§ If the key to be deleted is in a non-leaf node, swap it with a neighbouring <br>
key in a leaf and delete it<br>
§ If deletion leaves a node half empty, redistribute keys with a sibling node<br>§ If sibling node is only half full, combine with it (reverse of splitting)<br>§ If the root node ends up with no keys and one pointer, its child becomes <br>
the new root<br>
38<br>
<hr>
<A name=39></a><b>B-Tree Animation</b><br>
§ Inserting ...<br>§ Then finding ...<br>§ Then deleting ...<br>
B-Tree<br>
39<br>
<hr>
<A name=40></a><b>Reading</b><br>
§ Weiss: Sections 18.4, 18.8, 21.1-21.3, 21.5-21.7<br>
§ Drozdek: Sections 6.7, 6.8, and 7.1.1   <br>
Next session: Graphs<br>
Drozdek: Sections 8.1, 8.2 and 8.3 OR Weiss: Sections 13.1-13.4<br>
40<br>
<hr>
<A name=41></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
41<br>
<hr>
</BODY>
</HTML>
