<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 6 ­ Hash Tables<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<A name=2></a><b>Learning Objectives </b><br>
§ Understand and be able to use the data structures <br>set, tables and hash tables<br>
§ Be able to understand, apply and develop <br>algorithms to handle the data structures above. <br>Including:<br>
§Store key-value pairs<br>
§Retrieve values by key<br>
§Delete key-value pairs<br>
2<br>
<hr>
<A name=3></a><b>Sets</b><br>
3<br>
<hr>
<A name=4></a><b>Sets</b><br>
Sets in maths are a collection of things, no matter in which <br>order.<br>Sets are the simplest case of a table, in which the key is the <br>value<br>
§ The set stores values<br>§ The set can receive new values and store them<br>§ The set al ows checking whether a value is stored<br>§ Values can be deleted from the set<br>
There are many ways of implementing sets<br>
4<br>
<hr>
<A name=5></a><b>An abstract data type set</b><br>
public interface Set {<br>
// Add the key to the set<br>void insert(int key);<br>
// Is the key in the set?<br>boolean search(int key);<br>
// Delete the key from the set, if present<br>void delete(int key);<br>
}<br>
5<br>
<hr>
<A name=6></a><b>Known set implementations</b><br>
Unordererd array:<br>
Unordered linked list:<br>
§ insert at the end: O(1)<br>
§ insert at head: O(1)<br>
§ (sequential) search: O(n)<br>
§ (sequential) search: O(n)<br>
§ delete and swap: O(1)<br>
§ delete: O(1)<br>
§ search and delete: O(n)<br>
§ search and delete: O(n)<br>
Ordered array:<br>§ insert in proper place: O(n)<br>§ binary search: O(log n)<br>§ delete and shift: O(n)<br>§ search and delete: O(n)<br>
6<br>
<hr>
<A name=7></a><b>How can we do it faster ?</b><br>
Main problem: searching the right index.<br>
Takes long when using comparisons<br>
Idea: use <b>Hashing</b><br>
§ calculate the index from the key: gives constant time for finding <br>
the address.<br>
7<br>
<hr>
<A name=8></a><b>Some more implementations of sets</b><br>
Times for various implementations:<br>
<b>insert </b><br>
<b>search  delete</b><br>
unordered array <br>
O(1) <br>
O(n) <br>
O(n)<br>
ordered array <br>
O(n) <br>
O(log n)  O(n)<br>
linked list <br>
O(1) <br>
O(n) <br>
O(n)<br>
simple tree (best)<br>
O(log n)  O(log n)  O(log n)<br>
(worst) <br>
O(n) <br>
O(n) <br>
O(n)<br>
balanced search tree<br>
O(log n)  O(log n)  O(log n)<br>
<b>hash table </b><br>
<b>O(1) </b><br>
<b>O(1) </b><br>
<b>O(1)</b><br>
8<br>
<hr>
<A name=9></a><b>How to obtain O(1) in a set of integers?</b><br>
First approach:<br>§ take an array int array[max+1]; where max is the <br>
highest value to store<br>
§ initialise the values in the array to -1<br>§ store the values in slot index = key.<br>
E.g., array[24] = 24;<br>
9<br>
<hr>
<A name=10></a><b>First approach...</b><br>
insertion of key takes O(1):<br>void insert(int key){ array1[key] = key;}<br>
search for key takes O(1):<br>boolean search(int key) {<br>
if( array1[key] != -1) return true;<br>else<br>
return false;<br>
}<br>
deletion of key takes O(1):<br>void delete(int key) { array1[key] = -1;}<br>
10<br>
<hr>
<A name=11></a><b>Example</b><br>
Store 24, 31, 42 and 81 in set<br>
We get O(1), but:<br>
§ the maximum value (81) must be known when creating the array<br>
§ terribly wasteful (array of size 82 for 4 values!)<br>
11<br>
<hr>
<A name=12></a><b>How to use less space</b><br>
Keep the index inside the array bounds.<br>
Remember the modulo operator ?<br>
index &lt;- (key mod length) + 1<br>
makes sure the key is inside the array <br>(Java, 'mod' is '%' and '+1' is not needed)<br>
12<br>
<hr>
<A name=13></a><b>Ideal case </b><br>
Store 24, 31, 42 and 81 in set:<br>§ Ideally, we could create int array2[4]; and <br>
store value in array2[value % 4]; still O(1)<br>
§ To search value, check at array2[key % 4]; still O(1)<br>§ To delete value, delete array2[key % 4]<br>
This is a <b>hash table</b><br>
13<br>
<hr>
<A name=14></a><b>Tables (maps)</b><br>
14<br>
<hr>
<A name=15></a><b>Tables (maps)</b><br>
In sets, the keys were the data.<br>More often we have indexed data:<br>
§ There are other data associated to the keys<br>§ Examples: dictionaries, phone books, price lists, tables of contents<br>
It must be possible to add/remove elements<br>Examples:<br>
§ files/databases in general<br>§ files in a drive<br>§ variables in memory<br>§ commands in a language<br>
15<br>
<hr>
<A name=16></a><b>What is done in a table</b><br>
§ Data is stored as key-value pairs<br>§ Data is retrieved by key<br>
Implementations:<br>
§ ordered and unordered arrays<br>§ lists<br>§ hash tables<br>§ search trees<br>
16<br>
<hr>
<A name=17></a><b>An abstract data type table</b><br>
public interface Table {<br>
// Set the value associated with the key<br>void store(Key key, Data value);<br>
// Search for the key, returning true if found<br>boolean search(Key key);<br>
// If the key exists, return the value<br>// associated with it<br>int getValue(Key key);<br>
// Delete the key-value, if present<br>void delete(Key key);<br>
}<br>
17<br>
<hr>
<A name=18></a><b>The same example revisited </b><br>
Store 24, 31, 42 and 81 in set:<br>Ideally, we could create int array2[4]; and store<br>value in array2[key % 4]; still O(1)<br>
What if we want to store more values?<br>§ There is no more room in the array<br>
What if we want to store 82 instead of 81?<br>§ The fact that 82&gt;81 is not a problem<br>§ However, 82 mod 4 is 2, and array2[2] already contains a value: 42 (this is <br>
called a <b>collision</b>)<br>
18<br>
<hr>
<A name=19></a><b>Handling collisions</b><br>
Solution to the problems above:<br>
§ produce an array that has a size equal or reasonably greater than the number of <br>
elements you will want to store<br>
§ handle collision using some suitable strategy<br>
19<br>
<hr>
<A name=20></a><b>Hashing</b><br>
20<br>
<hr>
<A name=21></a><b>Hashing</b><br>
A <b>hash function </b>calculates the <i>index </i>for a <i>key</i><br>
<i>index &lt;- hash(key) </i>e.g.,  <i>key mod len</i><br>
Ideally there should be one unique index for each key (<b>perfect hash <br>function</b>)<br>
§ Pro: there would be no collisions<br>§ Con: we may not have enough space<br>
21<br>
<hr>
<A name=22></a><b>Avoiding collisions</b><br>
General strategy:<br>
§ Avoid collisions by distributing the keys uniformly over the addresses, <br>
even when there are patterns in the keys occurrence.<br>
Pattern examples:<br>
§ more small than large numbers<br>§ more even than odd numbers (or divisible by 4,10, ...)<br>
For modulo function: choose <i>len </i>prime<br>
22<br>
<hr>
<A name=23></a><b>What when collisions occur?</b><br>
In case of collision, the possible strategies are to:<br>
§store the value with the currently stored ones (buckets, closed <br>
hashing)<br>
§look for another empty space and store the value there (open <br>
addressing, open hashing)<br>
§modify the hashing function<br>
23<br>
<hr>
<A name=24></a><b>Buckets</b><br>
The idea is to store duplicates together<br>
§this could be done by using an array with pointers to arrays<br>§address may be assigned to several keys<br>§table of fixed size will overflow<br>
24<br>
<hr>
<A name=25></a><b>A hash table with chaining</b><br>
§Define the table as an array of objects of type Node,<br>§and create linked lists when collisions occur<br>
null<br>
31<br>
81 null<br>
42<br>
22<br>
12<br>
32 null<br>
null<br>
24<br>
84<br>
4 null<br>
25<br>
<hr>
<A name=26></a><b>A hash table class in Java</b><br>
class HashTable implements Set {<br>
private Node[] table;<br>
public HashTable(int size) {<br>
table = new Node[size];<br>
}<br>private int hash(int key) {<br>
return key%table.length;<br>
}<br>public void insert int key { ... }<br>public boolean search(int key) { ...}<br>public void delete(int key) { ... }<br>
26<br>
}<br>
<hr>
<A name=27></a><b>Searching</b><br>
To search <i>key</i>, sequential search is performed in the linked list <i>table[hash(key)]</i><br>
null<br>
31<br>
81 null<br>
42<br>
22<br>
12<br>
32 null<br>
null<br>
24<br>
84<br>
4 null<br>
Search for 22, 6, 100<br>
27<br>
<hr>
<A name=28></a><b>Searching</b><br>
To search <i>key</i>, sequential search is performed in the linked list <i>table[hash(key)]</i><br>
<i>Function search (key) :<br>p  table[hash(key)]<br>WHILE (p  null)</i><br>
<i>IF value of p = key THEN</i><br>
<i>Return key</i><br>
<i>p  next of p</i><br>
<i>Return null</i><br>
Insert and delete also work as with linked lists<br>
28<br>
<hr>
<A name=29></a><b>Inserting  </b><br>
Insert 16, 25<br>
null<br>
31<br>
81 null<br>
42<br>
22<br>
12<br>
32 null<br>
null<br>
24<br>
84<br>
4 null<br>
29<br>
<hr>
<A name=30></a><b>Deleting  </b><br>
Delete 81, 22, 31<br>
null<br>
31<br>
81 null<br>
42<br>
22<br>
12<br>
32 null<br>
null<br>
24<br>
84<br>
4 null<br>
30<br>
<hr>
<A name=31></a><b>Analysis of hash table operations</b><br>
The cost of operations is proportional to <br>
<b>load factor = number of elements / size of table</b><br>
§ If we use a fixed table size, the cost of operations will be O(n), though with a very small <br>
constant factor<br>
§ If we keep the <b>load factor bounded</b>, the cost of operations will be <b>O(1)</b>. For this, the <br>
table would need to be extended when adding elements (remember extensible arrays).<br>
31<br>
<hr>
<A name=32></a><b>Extending the hash table</b><br>
§ Simple scheme: create a new table, insert all the keys into it and discard the old one<br>§ Cost is proportional to the size of the table, say <i>cn</i>, so analysis is similar to extensible <br>
arrays<br>
§ If we <b>extend the table by doubling its size</b>, the cost of n insertions is at most<br>
<i>cn + cn/2 + cn/22 + ... + c = c (2n -1)        O(n)</i><br>
§ This yields an average, <b>amortised time of O(1) </b>per insertion<br>§ However, this cost is unevenly distributed<br>
32<br>
<hr>
<A name=33></a><b>Hash functions</b><br>
§ Java has a method hashCode for every Object<br>§ A <b>uniform distribution of keys </b>is essential<br>§ Division modulo a prime number (or a number with no small factors) is simple <br>
and often works well<br>
§ More complex transformations may be more uniform<br>§ For strings, combine the characters in some way<br>
§ For example, method hashCode for  String s computes<br>
310 s[n-1]+ 311 s[n-2]+ ... +31n-2 s[1] + 31n-1 s[0]<br>
33<br>
<hr>
<A name=34></a><b>Open addressing</b><br>
34<br>
<hr>
<A name=35></a><b>An alternative: Open Addressing</b><br>
Idea: to <b>save the space used by the pointers</b>, put the overflowing <br>entries (collisions) into the same array.<br>
Need to define <b>probing </b>method for where to put and search <br>elements:<br>
§ <b>Linear probing</b>: place the key in the next free slot<br>§ <b>Quadratic probing<br></b>§ <b>Double hashing</b><br>
35<br>
<hr>
<A name=36></a><b>Linear probing</b><br>
When inserting a key k:<br>
§ First try <i>h(k)<br></i>§ If that is used, try <i>(h(k) + 1) mod n</i>, <br>then <i>(h(k) + 2) mod n</i>, and so on<br>
On finding a free slot, place the key in it<br>
§ All locations in the array can be tried if necessary<br>§ Simple, but subject to clustering<br>
36<br>
<hr>
<A name=37></a><b>Linear probing ­ Insertion </b><br>
5 slots<br>Hash function h(n) = n%5<br>Insert 26, 3, 11<br>
37<br>
<hr>
<A name=38></a><b>Hashing with linear probing</b><br>
public class Set {<br>
private static String[] table;<br>public Set (int size){ table=new String[size];}<br>public boolean search(String key) {<br>
for(int i = key.hashCode()%table.length;<br>
table[i] != null; i=(i+1)%table.length){<br>
if (table[i].equals(key))<br>
return true;<br>
}<br>return false;<br>
}<br>
38<br>
}<br>
<hr>
<A name=39></a><b>Hashing with linear probing ­ Search</b><br>
5 slots<br>Hash function h(n) = n%5<br>Search 26, 11, 5<br>
0<br>1 26<br>
2 11<br>
3 3<br>
4<br>
39<br>
<hr>
<A name=40></a><b>Nearly full tables</b><br>
When the table is nearly ful , performance degrades sharply<br>
40<br>
<hr>
<A name=41></a><b>Clustering caused by linear probing</b><br>
Overflowing addresses tend to group in a region of the array<br>
41<br>
<hr>
<A name=42></a><b>Deleting elements</b><br>
Deletion requires creating a marker of deleted elements<br>
42<br>
<hr>
<A name=43></a><b>Inserting after deleting elements...</b><br>
After the deletion above, insert 6<br>
43<br>
<hr>
<A name=44></a><b>Quadratic probing</b><br>
Try <i>h(k) mod n</i>, <i>(h(k) <b>+ 12</b>) mod n</i>, <i>(h(k) <b>+ 22</b>) mod n</i>, <i>(h(k) <b>+ 32</b>) mod n</i>, and so on <br>until a free slot is found<br>
Probes i and j coincide if <i>n </i>divides i2 - j2 = (i - j)(i + j):<br>
§ If <i>n </i>is prime, this means <i>n </i>divides i - j or i + j, so i = j or i + j = n; so the sequence visits at <br>
least (n+1)/2 locations.<br>
§ (h(k) - 12) mod n, (h(k) - 22) mod n, and so on cover some of the other half (under some <br>
conditions al ).<br>
So it works better to try <i>h(k) mod n</i>, <i>(h(k) <b>+ 12</b>) mod n</i>, <i>(h(k) <b>-12</b>) mod n</i>,               <br><i>(h(k) <b>+ 22</b>) mod n</i>, <i>(h(k) <b>- 22</b>) mod n</i>, and so on.<br>
44<br>
<hr>
<A name=45></a><b>Quadratic probing</b><br>
Now insert 6<br>
45<br>
<hr>
<A name=46></a><b>Analysing quadratic probing</b><br>
§ <b>Keys that hash to different addresses probe different sequences of </b><br>
<b>addresses, eliminating primary clustering</b><br>
§ Keys that hash to the same address probe the same sequence of <br>
locations, so there is still secondary clustering, but this is less serious as <br>it is more distributed<br>
§ Ideally, to avoid secondary clustering, each probe should be different <br>
from those that came before<br>
§ An approximation to this is to use a second, independent hash function <br>
(double hashing)<br>
46<br>
<hr>
<A name=47></a><b>Double hashing</b><br>
We need <b>two hash functions </b><i>h1 </i>and <i>h2</i>, such that <i>h2(k) </i>is never divisible <br>by <i>n </i>nor equal to 0<br>
§ Try locations <i>h1(k) mod n</i>, <i>(h1(k) + h2(k)) mod n</i>, <i>(h1(k) + 2 h2(k)) mod n</i>, <br>
and so on<br>
§ This eliminates both primary and secondary clustering, but hashing twice <br>
costs some time<br>
§ We could also use a quadratic version:<br>
§ <i>h1(k) mod n</i>, <i>(h1(k) + h2(k)12) mod n</i>, <i>(h1(k)+h2(k)22) mod n</i>, and so on<br>
47<br>
<hr>
<A name=48></a><b>Double hashing example </b><br>
A good choice is to choose a prime p &lt; size and<br>h2(k) = p - (k % p)          (while h1(k) = k % n)<br>
7 slots; h1(k) = k%7; p=5; h2(k) = 5-(k%5)<br>
Insert 11, 18, 4<br>
Remember try:<br>h1(k) mod n; (h1(k) + h2(k)) mod n; (h1(k) + 2h2(k)) mod n<br>
48<br>
<hr>
<A name=49></a><b>Times for successful search</b><br>
49<br>
<hr>
<A name=50></a><b>Times for unsuccessful search</b><br>
50<br>
<hr>
<A name=51></a><b>Table/set operations</b><br>
<b>Search</b>:<br>hash to initial index and then follow probe sequence until<br>
§ the key is found, success,<br>§ an empty location is reached, failure<br>
<b>Insert </b>is like search, but put the key in the empty location<br>
<b>Delete </b>is harder, as many probe sequences pass through a given location. <br>Solution: indicate deletion with a special value<br>
51<br>
<hr>
<A name=52></a><b>Sets in Java</b><br>
There is a number of relevant interfaces and classes in the <br>package <b>java.util</b><br>
Interface <b>Set </b>defines a set ADT (extensive interface)<br>Implementations:<br>
§ <b>HashSet </b>(using a hash table)<br>§ <b>LinkedHashSet </b>(remembers insertion order)<br>
Interface <b>SortedSet </b>extends set ADT<br>Implementations:<br>
§ <b>TreeSet </b>(keeps keys sorted)<br>
52<br>
<hr>
<A name=53></a><b>Tables and Hashing in Java</b><br>
There is a number of relevant interfaces and classes in the <br>package <b>java.util</b><br>
Interface <b>Map </b>defines a table ADT (extensive interface)<br>Implementations:<br>
§ <b>HashMap </b>(<b>Hashtable </b>old sync. version)<br>§ <b>IdentityHashMap </b>(test for reference-identical keys)<br>
Interface <b>SortedMap </b>extends a map ADT<br>Implementations:<br>
§ <b>TreeMap </b>(keeps keys sorted)<br>
53<br>
<hr>
<A name=54></a><b>When to use Hashtables ?</b><br>
§ Hash tables have relatively low access times for large <br>
numbers of elements<br>
§ Hashing may be too expensive<br>§ For small collections, simple arrays can be better<br>§ May have high computing overhead when growing<br>§ Good when used for access by name (methods in compiler, <br>
telephone numbers in DB)<br>
§ HT do not know anything about order (except <br>
SortedMap/Set)<br>
54<br>
<hr>
<A name=55></a><b>Reading</b><br>
§ Weiss: Chapter 19 (Hash tables)  <br>
§ Drozdek: Chapter 10 (Hashing)   <br>
Next session: Trees<br>
Drozdek: Sections 6.1 to 6.6 OR Weiss: Chapters 17 and 18.1-18.3<br>
55<br>
<hr>
<A name=56></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
56<br>
<hr>
</BODY>
</HTML>
