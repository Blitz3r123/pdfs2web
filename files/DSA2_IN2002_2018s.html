<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 2 ­ Recursion and Abstract Data Types<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<A name=2></a><b>Learning Objectives</b><br>
§ Understand recursive algorithms<br>
§ What it means for an algorithm to be recursive<br>§ How to analyse a recursive algorithm in terms of time and space <br>
complexities<br>
§ Abstract data types <br>
§ What they are<br>§ How they are implemented<br>
2<br>
<hr>
<A name=3></a><b>Recursion</b><br>
3<br>
<hr>
<A name=4></a><b>Divide and Conquer</b><br>
Many algorithms have the form:<br>
§If the input is not simple, <b>divide </b>the input into simpler <br>
components, apply the algorithm recursively to each part, and <br><b>combine </b>the results obtained<br>
§Otherwise, <b>solve </b>it with a special algorithm<br>
4<br>
<hr>
<A name=5></a><b>Analysing divide and conquer algorithms</b><br>
You have to consider, for an input size of <i>n</i>:<br>
§If the input is simple<br>
§ the time the special algorithm takes<br>
§Otherwise, <br>
§ the time of dividing the input, plus<br>§ the time of processing the components, plus<br>§ the time of combining the results<br>§ ... and then solve the recursive definition.<br>
5<br>
<hr>
<A name=6></a><b>Recursion *</b><br>
A powerful way of programming using a function within itself<br>§ A problem is addressed by identifying:<br>
§ A step towards the next simpler case to which the same <br>
approach applies<br>
AND<br>
§ Result in the simplest case<br>
§ Recursion is, in a way, the reverse of proof by induction<br>
6<br>
* Introduced to you in Computation &amp; Reasoning<br>
<hr>
<A name=7></a><b>Example: Factorial<br></b>Problem: calculate <i>n</i>! = <i>n</i>·(<i>n</i>-1)·(<i>n</i>-2)·...·1<br>§ Step (for <i>n</i>&gt;0): <i>n</i>! = <i>n</i>·(<i>n</i>-1)!<br>§ Base (simplest) case: 0! = 1<br>This defines the value of n! for any natural number n.<br>
<i>Function factorial(n)<br>IF n = 0 THEN</i><br>
// 0<br>
<i>Return 1</i><br>
// 1<br>
<i>ELSE</i><br>
// 2<br>
<i>aux  factorial(n-1)</i><br>
// 3<br>
<i>Return n * aux</i><br>
// 4<br>
7<br>
<hr>
<A name=8></a>n     aux<br>
<i>Function factorial(n) </i>0<br>
<i>IF n = 0 THEN                     // 0</i><br>
<b>What is going on?</b><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
Cal ing factorial (2)<br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
1<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
2<br>
2<br>
2<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
8<br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<hr>
<A name=9></a>n     aux<br>
<i>Function factorial(n) </i>0<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<b>What is going on? (2)</b><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3<br>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
1<br>
1<br>
1<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
Returns 2<br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
n     aux<br>
<i>Function factorial(n)</i><br>
2<br>
2<br>
1<br>
<i>Function factorial(n) </i>2<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
9<br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<hr>
<A name=10></a><b>Understanding the Picture</b><br>
§ Recursive calls to factorial get pushed onto the stack<br>
§ Multiple copies of function factorial, each with different <br>
arguments &amp; local variable values, and execution at <br>different lines of the code<br>
§ All the computer really needs to remember for each active <br>
function call is the values of arguments &amp; local variables <br>and the location of the next statement to be executed when <br>control goes back <br>
10<br>
<hr>
<A name=11></a><b>The Stack</b><br>
n   aux  line<br>
0<br>
0<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
1<br>
0<br>
1<br>
3<br>
1<br>
1<br>
3<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
2<br>
0<br>
2<br>
3<br>
2<br>
3<br>
2<br>
3<br>
2<br>
1<br>
3<br>
11<br>
<hr>
<A name=12></a><b>What are "factorial's" the time and space <br>complexities?  </b><br>
§ Time complexity<br>
§ Calls itself n times<br>§ All other statements constant<br>§ ... hence O(??)<br>
§ Space complexity <br>
§ Calls itself n times (stack)<br>§ ... hence O(??)<br>
12<br>
<hr>
<A name=13></a><b>Example: power<br></b>Problem: calculate <i>xn<br></i>· Step (for <i>n&gt;0</i>): <i>xn = x · xn-1<br></i>· Base case: <i>x0 = 1<br></i>This defines the value of <i>xn </i>for any natural number <i>n</i>.<br>
<i>Function power(x, n):<br>IF n = 0 THEN</i><br>
<i>Return 1</i><br>
<i>ELSE</i><br>
<i>Return x * power(x, n-1)</i><br>
13<br>
<hr>
<A name=14></a><b>What are "power's" the time and space <br>complexities?  </b><br>
§ Time complexity<br>
§ Space complexity<br>
14<br>
<hr>
<A name=15></a><b>Tail Recursion</b><br>
void tail(int i) {<br>
if (i &gt; 0) {<br>
Tail recursion is when the <br>
System.out.println(i);<br>
recursive call is the last thing <br>
tail(i-1);<br>
done.<br>
}<br>
}<br>
void tailloop(int i) {<br>
while (i &gt; 0) {<br>
A loop can easily replace it.<br>
System.out.println(i);<br>i=i-1;<br>
}<br>
15<br>
}<br>
<hr>
<A name=16></a><b>Example of Tail Recursion: factorial</b><br>
<i>This factorial function is tail-recursive:</i><br>
int factorial(int n) {<br>
return fact(n, 1);<br>
}<br>
int fact (int n, int product) {<br>
if (n == 0){<br>
return product;<br>
}<br>return fact(n-1, n*product);<br>
}<br>
16<br>
<hr>
<A name=17></a><b>... Tail Recursive factorial</b><br>
int fact (int n, int product) {<br>
if (n == 0)<br>
return product;<br>
return fact(n-1, n*product);<br>
}<br>
<i>And can easily be converted </i><br>
int fact(int n, int product) {<br>
<i>into iterative (i.e. a loop).</i><br>
while(n&gt;0) {<br>
product = n*product;<br>n = n-1;<br>
}<br>return product;<br>
}<br>
17<br>
<hr>
<A name=18></a><b>Another Example of Recursion</b><br>
What does this function do?<br>
void printNum(int n) {<br>
if (n &gt;= 10){<br>
printNum(n/10);<br>
}<br>System.out.print(n%10);<br>
}<br>
18<br>
<hr>
<A name=19></a><b>A Call Tree for printNum</b><br>
printNum(1234)<br>
printNum(123)<br>
printNum(12)<br>
printNum(1)<br>
System.out.print(`1')<br>
System.out.print(`2')<br>
System.out.print(`3')<br>
System.out.print(`4')<br>
19<br>
<hr>
<A name=20></a><b>What are "printNum's" the time and space <br>complexities?</b><br>
§ Time complexity<br>
§ Calls itself log n times<br>§ All other statements constant<br>§ ... hence O(??)<br>
§ Space complexity <br>
§ Calls itself log n times (stack)<br>§ ... hence O(??)<br>
20<br>
<hr>
<A name=21></a><b>Another example for recursion (exam 2014-15)</b><br>
<b>Recursion   </b>(15%)<br>You are given the code for <i>bla </i>below. <br>
void bla (int i)  {<br>
if (i &gt; 0) {<br>
System.out.print (i + " ");<br>bla(i ­ 1);<br>
}<br>
}<br>
21<br>
<hr>
<A name=22></a><b>Another example for recursion (exam 2014-15) ­<br>cont'd</b><br>
a) Describe what <i>bla </i>does.  (5%)<br>
b) What is its time complexity? Justify your answer.  (5%)<br>
c) What is its space complexity? Justify your answer.  (5%)<br>
22<br>
<hr>
<A name=23></a><b>Applications of Recursion</b><br>
Recursion is useful for:<br>
§ designing algorithms<br>§ traversing branching structures (like trees and graphs)<br>§ writing parsers<br>§ backtracking search algorithms<br>§ divide-and-conquer algorithms<br>
23<br>
<hr>
<A name=24></a><b>Pros and Cons of Using Recursion</b><br>
§Pros<br>
§often elegant solutions<br>
§compact code<br>
§proving correctness often relatively easy<br>
§Cons<br>
§careful algorithm design necessary<br>
§hard to debug (better prove correctness)<br>
§function call stack needs extra memory and is often limited<br>
24<br>
<hr>
<A name=25></a><b>Common Computations</b><br>
· Why do we often discuss sorting algorithms?<br>
· How about searching?<br>
· Insertion?<br>
· Deletion?<br>
25<br>
<hr>
<A name=26></a><b>Sorting Algorithms</b><br>
· What are examples of sorting algorithms?<br>
· How fast are they?<br>
26<br>
<hr>
<A name=27></a><b>Sorting Algorithms</b><br>
<b>Space </b><br>
<b>Average time  Worst case </b><br>
<b>complexity</b><br>
<b>complexity</b><br>
<b>time <br>complexity</b><br>
Selection sort O(1)<br>
O(n2)<br>
O(n2)<br>
Insertion sort<br>
O(1)<br>
O(n2)<br>
O(n2)<br>
Quicksort<br>
O(log n)<br>
O(n log n)<br>
O(n2)<br>
Mergesort<br>
O(n)<br>
O(n log n)<br>
O(n log n)<br>
27<br>
<hr>
<A name=28></a><b>Other Common Computations</b><br>
· How about searching?<br>
· Insertion?<br>
· Deletion?<br>
28<br>
<hr>
<A name=29></a><b>Deletion Algorithm</b><br>
· How do we delete an element of an array?<br>
· What if the array is sorted?<br>
· How often do we need to delete new elements?<br>
29<br>
<hr>
<A name=30></a><b>Food for Thought</b><br>
· Should we always use arrays to store and manipulate our data? <br>
· Should we always sort their contents?<br>
30<br>
<hr>
<A name=31></a><b>Abstract Data Types</b><br>
31<br>
<hr>
<A name=32></a><b>Abstract Data Types  (ADTs)</b><br>
§Abstract data types<br>
§separate functionality from implementation<br>
§hidden representation<br>§manipulated via a limited set of operations<br>§in Java, interfaces with defined method semantics<br>
§Data structures<br>
§concrete implementations, often subject to an invariant preserved by <br>the operations<br>§in Java: classes implementing ADT interfaces<br>§are analysed by measuring the time and space complexity of  the <br>structure and each  operation<br>
32<br>
<hr>
<A name=33></a><b>ADT Stack</b><br>
Think of physical stacks:<br>
§ series of similar elements<br>§ you add elements on the top<br>§ you take the elements from the top<br>
... so the last element in is the first out (LIFO)<br>
33<br>
<hr>
<A name=34></a><b>Stack Operations</b><br>
You can only remove the last element added.<br>
The operations are thus:<br>
§ Add an element to the stack<br>§ Remove the last element added<br>§ Check whether the stack is empty.<br>
34<br>
<hr>
<A name=35></a><b>A stack in Java</b><br>
// a stack of integers<br>public interface Stack {<br>
// is the stack empty?<br>boolean isEmpty();<br>
// add (push) an element into the stack<br>void push(int elt);<br>
// remove and return the most recently pushed<br>// element still in the stack<br>int pop();<br>
35<br>
}<br>
<hr>
<A name=36></a><b>A stack implementation using an array</b><br>
<i>public class ArrayStack implements Stack {</i><br>
<i>private int[] a;<br>private int count = 0;</i><br>
<i>public ArrayStack(int size) {a = new int[size];}</i><br>
<i>public boolean isEmpty() { return count == 0; }</i><br>
<i>public void push(int elt) { a[count++] = </i><br>
<i>elt; }</i><br>
<i>public int pop() { return a[--count]; }</i><br>
<i>}</i><br>
36<br>
<hr>
<A name=37></a><b>Checking Brackets with a Stack</b><br>
opening bracket:  push on stack<br>closing bracket: pop from stack and match<br>
String <br>
Stack<br>
Op<br>
( [ ] ( [ ) ] )<br>
push<br>
[ ] ( [ ) ] ) <br>
( <br>
push<br>
] ( [ ) ] )<br>
( [ ) ] )<br>
[ ) ] )<br>
) ] )<br>
37<br>
<hr>
<A name=38></a><b>Priority Queues</b><br>
§ You can only remove the element with the highest priority<br>§ Examples: printer queues, emergency rooms, council housing<br>
38<br>
<hr>
<A name=39></a><b>Priority Queue Operations</b><br>
§ Add an element<br>§ Remove an element: the element removed is the one with <br>
the highest priority<br>
§ Check whether the queue is empty<br>
39<br>
<hr>
<A name=40></a><b>Applications of Priority Queues</b><br>
§ As a component of various algorithms<br>§ Sorting: add all the items to the priority queue and then <br>
extract them one by one<br>
§ Scheduling (e.g. in operating systems, post, air traffic)<br>§ Event-driven simulation<br>
40<br>
<hr>
<A name=41></a><b>Scheduling</b><br>
Several tasks should be performed with different priorities<br>For example...<br>
We want to produce a system for parcel deliveries. The priority could be <br>set by using the guaranteed date of delivery and the time at which the <br>parcel was posted.<br>
§ The priority queue would be handled by storing the parcels in the depot <br>
and releasing them for delivery according to their priority.<br>
§ In busy days, probably only those parcels whose delivery is due - i.e., <br>
those that have the highest priority - could be delivered.<br>
§ In less busy days, parcels would be delivered in advance of their <br>
41<br>
guaranteed date of delivery.<br>
<hr>
<A name=42></a><b>Event-Driven Simulation</b><br>
<i>We wish to simulate a series of events, each considered to occur at a point in </i><br>
<i>simulated time.</i><br>
Nothing happens between events, so maintain a collection of pending events, and repeat:<br>
§ extract the first pending event<br>
§ advance the simulation clock to its time<br>
§ simulate the event<br>
Events may change the state, and may cause other events at later times, i.e. add further <br>
events to the collection<br>
Useful for load analysis and prediction<br>
e.g., for Internet nodes, road or air traffic, emergency procedures.<br>
42<br>
<hr>
<A name=43></a><b>A priority queue ADT</b><br>
// A priority queue of integers<br>public interface PriorityQueue {<br>
// Is the priority queue empty?<br>boolean isEmpty();<br>
// Add an element to the priority queue<br>void add(int elt);<br>
// Remove and return the largest value<br>// currently in the priority queue<br>int extractMax();<br>
}<br>
43<br>
<hr>
<A name=44></a><b>An implementation using a sorted array</b><br>
<i>A way of implementing priority queues is to keep the elements <br>in a sorted array, so:</i><br>
§ <i>to add an element, search and insertion are used<br></i>§ <i>to extract an element, the last element in the array is </i><br>
<i>extracted (as it will have the highest priority)</i><br>
44<br>
<hr>
<A name=45></a><b>Concrete Implementation in Java</b><br>
public class ArrayPQ implements PriorityQueue {<br>
private int[] data;<br>private int count = 0;<br>
public ArrayPQ(int size){ data = new int[size]; }<br>
public boolean isEmpty(){ return count == 0; }<br>
public void add(int elt){<br>
insert(data, count++, elt);<br>
}<br>
public int extractMax(){ return data[--count]; }<br>
45<br>
}<br>
<hr>
<A name=46></a><b>Analysing the use of the Data Structure</b><br>
§ The data structure takes O(n) space complexity<br>
§ By using the ordered array data structure:<br>
§ isEmpty takes time O(??)<br>§ add takes time O(??)<br>§ extractMax takes time O(??)<br>
§ The ordering constraint is very restrictive, maintaining it by <br>
insertions costs O(n) time.<br>
46<br>
<hr>
<A name=47></a><b>An Alternative Implementation</b><br>
What would happen if the representation were an unordered array?<br>
In that case:<br>
§ isEmpty takes time O(??)<br>§ add takes time O(??)<br>§ extractMax takes time O(??)<br>
It is an equivalent situation, but slow at extracting.<br>
47<br>
<hr>
<A name=48></a><b>Is there a better implementation?</b><br>
48<br>
<hr>
<A name=49></a><b>Reading</b><br>
§ Weiss: Chapter 7, and chapter 15 section 1.1  <br>
§ Drozdek: Chapter 5, and chapter 4 sections 4.1and 4.3  <br>
Next week: Trees and heapsort<br>
49<br>
<hr>
<A name=50></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
50<br>
<hr>
</BODY>
</HTML>
