<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 5 ­ Other Linked Lists<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<A name=2></a><b>Learning Objectives </b><br>
§ Understand and be able to use the data structures <br>circular lists and doubly linked lists<br>
§ Be able to understand, apply and develop <br>algorithms to handle the lists above. Including:<br>
§Adding elements<br>
§Deleting elements <br>
§Traversing a list<br>
2<br>
<hr>
<A name=3></a><b>Pointers and Linked Lists</b><br>
3<br>
<hr>
<A name=4></a><b>Database Records</b><br>
All object variables in Java are actually pointers<br>
A pointer is a link to some object, i.e. a piece of memory:<br>
§ Links can be thought of as arrows, addresses or references<br>§ They point at an object that is somewhere in the system's <br>
memory<br>
4<br>
<hr>
<A name=5></a><b>Links and their behaviour</b><br>
Links point at objects<br>
Node p;<br>
5<br>
8<br>
3<br>
Node q;<br>
null<br>
p is <br>q.info is <br>p.next is <br>q.next.info is <br>q.next.next is <br>p.next.next.info is <br>
5<br>
<hr>
<A name=6></a><b>Links and their behaviour </b><br>
Links point at objects<br>
Node p;<br>
5<br>
8<br>
3<br>
Node q;<br>
null<br>
p.next = null;<br>
p = null; <br>
6<br>
<hr>
<A name=7></a><b>Assigning to links</b><br>
r<br>
p<br>
5<br>
8<br>
3<br>
null<br>
q<br>
r<br>
p = null;<br>
p<br>
5<br>
8<br>
3<br>
7<br>
q<br>
<hr>
<A name=8></a><b>Assigning to links</b><br>
r<br>
p<br>
5<br>
8<br>
3<br>
null<br>
q<br>
r<br>
p.next = null;<br>
p<br>
5<br>
8<br>
3<br>
q<br>
null<br>
8<br>
<hr>
<A name=9></a><b>Assigning to links</b><br>
p<br>
5<br>
8<br>
3<br>
null<br>
q<br>
p.next = null;<br>
p<br>
5<br>
8<br>
3<br>
q<br>
9<br>
<hr>
<A name=10></a><b>Evaluation of links</b><br>
p<br>
5<br>
8<br>
3<br>
null<br>
q<br>
r = q.next.next;<br>s = p.next;<br>
s<br>
r<br>
p<br>
5<br>
8<br>
3<br>
q<br>
10<br>
<hr>
<A name=11></a><b>Singly linked lists</b><br>
Our implementation uses two types of objects:<br>
§<i>SLList</i>, which has two components: <i>head </i>and <i>tail<br></i>§<i>Node</i>, which has two components: <i>info </i>and <i>next</i><br>
<i>head</i>, <i>tail </i>and <i>next </i>are of type <i>Node</i>, so they contain links<br><i>info </i>is of the type of information elements you want to store<br>
11<br>
<hr>
<A name=12></a><b>Traversing a singly linked list</b><br>
<i>Function printList():<br>node1  head of list<br>WHILE node1 is not nul</i><br>
<i>print value of node1<br>node1  next of node1</i><br>
... so to traverse the list, iteratively (or recursively!) <br>evaluate the rest of the list (i.e., use next)<br>
12<br>
<hr>
<A name=13></a><b>Circular Lists</b><br>
13<br>
<hr>
<A name=14></a><b>A Circular List</b><br>
CList<br>
We use object type <i>CList</i>, which has <br>
Node tail;<br>
one component: <i>tail</i><br>
The head is <i>tail.next</i><br>
5<br>
8<br>
3<br>
14<br>
<hr>
<A name=15></a><b>Circular lists in Java</b><br>
public class CList {<br>
private Node tail = null;<br>
public boolean isEmpty() {<br>
return tail == null;<br>
}<br>
public void addToHead(int el) {...}<br>
public void addToTail(int el) {...}<br>
public int deleteFromHead () {...}<br>
15<br>
}<br>
<hr>
<A name=16></a><b>Some special cases</b><br>
An empty list <br>
A list with one element<br>
CList<br>
CList<br>
Node tail;<br>
Node tail;<br>
null<br>
3<br>
16<br>
<hr>
<A name=17></a><b>Adding at the head of a circular list </b><br>
17<br>
<hr>
<A name=18></a><b>Adding at the head of a circular list... in Java </b><br>
Remember that head is really tail.next<br>
public void addToHead(int el) {<br>
if (isEmpty()) {<br>
// create a new node pointing at itself<br>tail = new Node(el);<br>tail.next = tail;<br>
} else { // update the head<br>
tail.next = new Node(el, tail.next);<br>
}<br>
}<br>
18<br>
<hr>
<A name=19></a><b>Adding at the tail of a circular list </b><br>
19<br>
<hr>
<A name=20></a><b>Adding at the tail of a circular list ... in Java</b><br>
public void addToTail(int el) {<br>
addToHead(el);<br>tail = tail.next;<br>
}<br>
20<br>
<hr>
<A name=21></a><b>Deleting the head of a circular list </b><br>
21<br>
<hr>
<A name=22></a><b>Deleting the head of a circular list ... in Java</b><br>
public int deleteFromHead() {<br>
int el = tail.next.info;<br>if (tail == tail.next)<br>
tail=null;<br>
else<br>
tail.next = tail.next.next;<br>
return el;<br>
}<br>
22<br>
<hr>
<A name=23></a><b>Traversing a circular list</b><br>
23<br>
<hr>
<A name=24></a><b>Traversing a circular list... in Java </b><br>
Consider that the end of the circular list is not marked by <i>null</i>, but by <i>tail</i>:<br>
public void printList() {<br>
if (! isEmpty()) {<br>
Node p = tail;<br>do {<br>
p = p.next;<br>System.out.println(p.info);<br>
} while (p != tail);<br>
}<br>
}<br>
24<br>
<hr>
<A name=25></a><b>Example Analysis: Traversing a circular list </b><br>
public void printList() {<br>
if (! isEmpty()) {<br>
Node p = tail;<br>do {<br>
p = p.next;<br>System.out.println(p.info);<br>
} while (p != tail);<br>
}<br>
}<br>One loop. Execution starts after tail, and ends at tail. Therefore loop <br>executed once for each element. Running time is <i>O</i>(<i>n</i>).<br>Only Node p uses memory, none allocated in loop. Memory usage is <i>O</i>(1). <br>
25<br>
Both apply to best, worst, and average case.<br>
<hr>
<A name=26></a><b>Analysis of circular lists</b><br>
They perform like singly linked lists:<br>
§ efficient support of the Stack and Queue ADTs<br>§ store n elements in O(n) space<br>§ all defined operations take O(1) time<br>§ cannot efficiently delete last element<br>§ can be traversed from head to tail, but not the other way around <br>
Applications: resource sharing, load balancing<br>
26<br>
<hr>
<A name=27></a><b>Doubly Linked Lists</b><br>
27<br>
<hr>
<A name=28></a><b>Doubly Linked Lists</b><br>
Each node has two pointers: one to its successor and<br>another to its predecessor<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
null<br>
null<br>
28<br>
<hr>
<A name=29></a><b>A node in a doubly linked list </b><br>
public class DLLNode {<br>
public int info;<br>public DLLNode next, prev;<br>
public DLLNode(int i, DLLNode n, DLLNode p) {<br>
info = i; next = n; prev = p;<br>
}<br>
public DLLNode(int i) {<br>
this(i, null, null);<br>
}<br>
}<br>
29<br>
<hr>
<A name=30></a><b>The doubly linked list class</b><br>
public class DLList {<br>
private DLLNode head = null;<br>private DLLNode tail = null;<br>
public boolean isEmpty() {<br>
return head == null;<br>
}<br>
public void addToHead(int el) {...}<br>public void addToTail(int el) {...}<br>public int deleteFromHead() {...}<br>public int deleteFromTail() {...}<br>
}<br>
30<br>
<hr>
<A name=31></a><b>Adding an element at the tail</b><br>
Suppose we want to add an element 72 to the tail of the list<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
72<br>
null<br>
null<br>
31<br>
<hr>
<A name=32></a><b>Adding an element at the tail (step 1):<br>create a new node and reset tail</b><br>
tail = new DLLNode(el, null, tail);<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
72<br>
null<br>
null<br>
null<br>
32<br>
<hr>
<A name=33></a><b>Adding an element at the tail (step 2):<br>connect the node to the list</b><br>
tail.prev.next = tail;<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
72<br>
null<br>
null<br>
33<br>
<hr>
<A name=34></a><b>Adding an element at the tail... in Java</b><br>
If the list is not empty, create and connect the node<br>Otherwise, just create a new node.<br>
public void addToTail(int el) {<br>
if (! isEmpty()) {<br>
tail = new DLLNode(el, null, tail);<br>tail.prev.next = tail;<br>
} else<br>
head = tail = new DLLNode(el);<br>
}<br>
34<br>
<hr>
<A name=35></a><b>Deleting the last node</b><br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
19<br>
null<br>
null<br>
35<br>
<hr>
<A name=36></a><b>Deleting the last node (step 1):<br>move the tail pointer</b><br>
tail = tail.prev;<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
19<br>
null<br>
null<br>
36<br>
<hr>
<A name=37></a><b>Deleting the last node (step 2):<br>disconnect the last node</b><br>
tail.next = null;<br>
DLList<br>head<br>tail<br>
8<br>
3<br>
5<br>
19<br>
null<br>
null<br>
null<br>
37<br>
<hr>
<A name=38></a><b>Deleting the last node... in Java</b><br>
If the list has more than one node, move tail and disconnect last node. <br>Otherwise, empty the list<br>
public int deleteFromTail() {<br>
int el = tail.info;<br>if (head == tail)<br>
head = tail = null;<br>
else {<br>
tail = tail.prev;<br>tail.next = null;<br>
}<br>return el;<br>
}<br>
38<br>
<hr>
<A name=39></a><b>Deleting any node</b><br>
If we wish to delete the node p points to<br>
DLList<br>head<br>
<b>p</b><br>
tail<br>
8<br>
3<br>
5<br>
12<br>
null<br>
39<br>
<hr>
<A name=40></a><b>Deleting any node</b><br>
If we wish to delete the node p points to, we need to bridge over it:<br>p.next.prev = p.prev;<br>
DLList<br>
p.prev.next = p.next;<br>
head<br>
<b>p</b><br>
tail<br>
8<br>
3<br>
5<br>
12<br>
null<br>
We may also need to adjust head and/or tail.<br>
40<br>
<hr>
<A name=41></a><b>Deleting any node... in Java</b><br>
public void delete(DLLNode p) {<br>
if (p.prev == null)<br>
head = p.next;<br>
else<br>
p.prev.next = p.next;<br>
if (p.next == null)<br>
tail = p.prev;<br>
else<br>
p.next.prev = p.prev;<br>
}<br>
What happens if it has only one node?<br>
41<br>
<hr>
<A name=42></a><b>Traversing a doubly linked list... in Java</b><br>
It is just as easy to go in either direction:<br>
public void forwards() {<br>
for (DLLNode p = head; p != null; p = p.next)<br>
System.out.println(p.info);<br>
}<br>
public void backwards() {<br>
for (DLLNode p = tail; p != null; p = p.prev)<br>
System.out.println(p.info);<br>
}<br>
42<br>
<hr>
<A name=43></a><b>Java Traversal Specialist Classes: Iterators</b><br>
Iterators encapsulate traversal. In Java defined in java.util<br>
interface Iterator&lt;E&gt; {<br>
boolean<br>
hasNext(); // Returns true if the<br>
// iteration has more elements.<br>
E next(); // Returns the next element in the <br>
// iteration.<br>
void  remove(); // Removes from the underlying<br>
// collection the last element returned by<br>// the iterator. <br>
}<br>
43<br>
<hr>
<A name=44></a><b>Java Traversal Specialist Classes: ListIterators</b><br>
ListIterators support backwards traversal and addition.<br>
interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {<br>
boolean<br>
hasPrevious(); // Returns true if the<br>
// iterator has further elements when traversing <br>// in reverse direction.<br>
E previous(); // Returns the previous element in <br>
// the list.<br>
void add(E e); // Inserts the specified element <br>
// into the list.<br>
... // more methods <br>
}<br>
44<br>
<hr>
<A name=45></a><b>Reading</b><br>
§ Weiss: Section 16.3 (doubly linked lists and circular lists)  <br>
§ Drozdek: Sections 3.2 (doubly linked lists) and 3.3 (circular <br>
lists)  <br>
Next session (IN 2 WEEKS TIME): Hash tables<br>
Drozdek: Chapter 10 (Hashing) OR Weiss: Chapter 19 (Hash tables)<br>
45<br>
<hr>
<A name=46></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
46<br>
<hr>
</BODY>
</HTML>
