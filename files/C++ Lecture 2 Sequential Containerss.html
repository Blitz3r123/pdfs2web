<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a>Session 2 ­ Sequential containers<br>
IN2029: Programming in C++<br>
Session 2 ­ Sequential containers<br>
Ross Paterson<br>
Department of Computer Science<br>
City, University of London<br>
Autumn term, 2018<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
1 / 25<br>
<hr>
<A name=2></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
This session<br>
We'll be writing some programs that operate on batches of data, which<br>allows us to explore<br>
a bit more about streams<br>
the standard idiom for looping to the end of an input stream<br>
manipulators<br>
vectors from the standard template library<br>
introduction to containers<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
2 / 25<br>
<hr>
<A name=3></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Calculating statistics from a list of numbers<br>
<b>Task: </b>read in a list of numbers and print their average.<br>
The overall structure of our program will be:<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;iomanip&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>// ... read in data ...</b><br>
<b>// ... print results ...</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
3 / 25<br>
<hr>
<A name=4></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Reading the data<br>
The first part is to read all the numbers and record their count and sum:<br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
<b>// the number and total of values read</b><br>
<b>int count = 0;</b><br>
<b>double sum = 0;</b><br>
<b>// read values from standard input</b><br>
<b>double x; // a variable for reading into</b><br>
<b>while (cin &gt;&gt; x) {</b><br>
<b>++count;</b><br>
<b>sum += x;</b><br>
<b>}</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
4 / 25<br>
<hr>
<A name=5></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Library details: testing for end-of-input<br>
We have already seen that the <b>&gt;&gt; </b>operator returns the input stream, in<br>statements like<br>
<b>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</b><br>
But the result of <b>&gt;&gt; </b>can also be used in a test, as in the common idiom<br>for reading a series of things and testing for the end of the input:<br>
<b>while (cin &gt;&gt; x) {</b><br>
<b>// .. do something with x</b><br>
<b>}</b><br>
Testing a stream yields <b>true </b>if the last operation on the stream<br>succeeded, and <b>false </b>if it didn't.<br>(You can indicate end of input on the console by typing Control-Z<br>Return on Windows, or Control-D on Unix.)<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
5 / 25<br>
<hr>
<A name=6></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Language details: <b>i++ </b>vs <b>++i</b><br>
The following statements all increase an <b>int </b>variable <b>i </b>by one:<br>
<b>i = i+1;</b><br>
<b>i += 1;</b><br>
<b>i++;</b><br>
<b>++i;</b><br>
The difference between the last two is only seen when the value of the<br>expression is used:<br>
<b>int i = 5;</b><br>
<b>int j = ++i; // j is set to 6; i is now 6</b><br>
<b>int k = i++; // k is also set to 6; i is now 7</b><br>
<b>i++ </b>returns the value before incrementing (so the old value has to<br>be saved somewhere, which could be expensive with some types)<br>
<b>++i </b>returns the value after incrementing (simpler)<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
6 / 25<br>
<hr>
<A name=7></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Printing the results<br>
Finally, we want to print the results:<br>
<b>cout &lt;&lt; count &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (count &gt; 0) {</b><br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; sum/count &lt;&lt; '\n';</b><br>
<b>}</b><br>
By default, floating point numbers are printed with up to 5 significant<br>figures, but we can change that:<br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; setprecision(3) &lt;&lt;</b><br>
<b>sum/count &lt;&lt; '\n';</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
7 / 25<br>
<hr>
<A name=8></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Library details: manipulators<br>
<b>setprecision(3) </b>is an example of a stream manipulator (from the<br><b>&lt;iomanip&gt; </b>system header), like <b>flush </b>or <b>endl</b>: a special kind of<br>object with an overloading of the <b>&lt;&lt; </b>operator than changes the state of<br>the stream.<br>This manipulator is used to adjust formatting:<br>
<b>cout &lt;&lt; setprecision(3);</b><br>
doesn't do any output, but it sets the precision for any following output.<br>
<b>cout &lt;&lt; setprecision(3) &lt;&lt; x &lt;&lt;</b><br>
<b>setprecision(5) &lt;&lt; y;</b><br>
Other manipulators set base, paddings, etc.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
8 / 25<br>
<hr>
<A name=9></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Cleaning up<br>
We have used <b>setprecision </b>to set the maximum number of<br>decimal places to what we want.<br>
Nothing else is happening in this program, but in general it would<br>be polite to set the precision back to what it was before.<br>
We can get the current precision using <b>cout.precision()</b>.<br>
This yields our final version:<br>
<b>int prec = cout.precision();</b><br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; setprecision(3) &lt;&lt;</b><br>
<b>sum/count &lt;&lt; setprecision(prec) &lt;&lt; '\n';</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
9 / 25<br>
<hr>
<A name=10></a>Session 2 ­ Sequential containers<br>
Example: computing averages<br>
Breaking the input into words<br>
An example reading strings:<br>
<b>#include &lt;string&gt;</b><br>
<b>#include &lt;iostream&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>string s;</b><br>
<b>while (cin &gt;&gt; s)</b><br>
<b>cout &lt;&lt; s &lt;&lt; '\n';</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Recall that the <b>&gt;&gt; </b>operator on strings reads words.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
10 / 25<br>
<hr>
<A name=11></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Calculating a different statistic<br>
<b>Task: </b>read in a list of numbers and print their median.<br>
The median of a collection of numbers is the "middle" value when they<br>are arranged in order:<br>
1 3 3 7 10 11 11 13 14 15 15<br>
However, the input data may be in any order.<br>
Unlike computing the average, to compute the median we will<br>need to store all the numbers until the end of the program. We<br>shall use a <b>vector </b>to do this.<br>
Then we need to arrange the values in order. We shall use the<br>library function <b>sort</b>.<br>
Then the median will be the middle value in the vector.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
11 / 25<br>
<hr>
<A name=12></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Outline<br>
The overall structure of our program will be:<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;vector&gt;</b><br>
<b>#include &lt;algorithm&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>// ... read and store the data ...</b><br>
<b>// ... sort the data ...</b><br>
<b>// ... print the middle value ...</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
12 / 25<br>
<hr>
<A name=13></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Vectors<br>
<b>#include &lt;vector&gt;</b><br>
C++ has arrays, but we'll use vectors instead (a container like<br>ArrayList in Java, except that a variable of <b>vector </b>type holds an<br>object, not a reference):<br>
<b>vector&lt;int&gt; vi;</b><br>
<b>// empty vector of ints</b><br>
<b>vector&lt;string&gt; vs;</b><br>
<b>// empty vector of strings</b><br>
Vectors also be extended:<br>
<b>vs.push_back(s);</b><br>
The current length of <b>vs </b>is <b>vs.size()<br></b>Vectors can be accessed just like arrays (indices 0 . . . <b>size()-1</b>):<br>
<b>vi[1] = x;</b><br>
<b>vi[2] = vi[1] + 3;</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
13 / 25<br>
<hr>
<A name=14></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Reading the data into a vector<br>
We start by reading all the numbers and storing them in a vector:<br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
<b>// read numbers from the standard input</b><br>
<b>// and store them in a vector</b><br>
<b>vector&lt;double&gt; v;</b><br>
<b>double x;</b><br>
<b>while (cin &gt;&gt; x)</b><br>
<b>v.push_back(x);</b><br>
We don't need a separate variable to count them: we can use<br><b>v.size()</b>.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
14 / 25<br>
<hr>
<A name=15></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Finding the median: outline<br>
Only a non-empty vector can have a median.<br>
First, we need to sort the vector.<br>
<b>// compute and output results</b><br>
<b>unsigned n = v.size();</b><br>
<b>cout &lt;&lt; n &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (n &gt; 0) {</b><br>
<b>// sort the whole vector</b><br>
<b>sort(v.begin(), v.end());</b><br>
<b>// ... find the middle value</b><br>
<b>}</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
15 / 25<br>
<hr>
<A name=16></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Language details: unsigned types<br>
C++ has signed and unsigned integral types of various sizes:<br>
Signed<br>
?<br>
Unsigned<br>
<b>signed char</b><br>
<b>char</b><br>
<b>unsigned char</b><br>
<b>short</b><br>
<b>unsigned short</b><br>
<b>int</b><br>
<b>unsigned int </b>(or <b>unsigned</b>)<br>
<b>long</b><br>
<b>unsigned long</b><br>
<b>long long</b><br>
<b>unsigned long long </b>(in C++11)<br>
Unlike in Java, the sizes are not defined by the standard (but they<br>are non-decreasing).<br>
<b>char </b>may be either a signed or unsigned type, whichever is more<br>efficient on this architecture.<br>
Unsigned types cannot be negative: if <b>i </b>is of unsigned type,<br><b>i &lt; 0 </b>can never be <b>true</b>.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
16 / 25<br>
<hr>
<A name=17></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Unsigned types: caution<br>
Unsigned integers will silently underflow:<br>
<b>unsigned i = 0;</b><br>
<b>i -= 1;</b><br>
will not fail ­ it will set <b>i </b>to a very large positive number.<br>
If an operation involves both a signed and unsigned type, it will<br>silently convert the signed type to unsigned first, so in<br>
<b>int i = -5;</b><br>
<b>unsigned j = 1;</b><br>
<b>if (i &lt; j)</b><br>
the last test will fail, because <b>-5 </b>will be silently converted to a very<br>large positive number.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
17 / 25<br>
<hr>
<A name=18></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
The type of <b>size()</b><br>
Containers cannot have negative size.<br>
The return type of the <b>size() </b>member function is an unsigned<br>type, but which unsigned type is implementation dependent.<br>
The portable name of its type is<br><b>vector&lt;double&gt;::size_type</b>.<br>
Here <b>:: </b>selects a static attribute of the type <b>vector&lt;double&gt;</b>.<br>(This is a different use of <b>:: </b>from namespace qualification, as in<br><b>std::vector</b>.)<br>
We can use this as the type of the variable <b>n</b>:<br>
<b>vector&lt;double&gt;::size_type n = v.size();</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
18 / 25<br>
<hr>
<A name=19></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Library details: <b>sort</b>, <b>begin</b>, <b>end</b><br>
<b>sort(v.begin(), v.end());</b><br>
To sort a vector, we use the <b>sort </b>function, declared in the<br><b>&lt;algorithms&gt; </b>system header.<br>
Instead of a container, <b>sort </b>takes two positions or iterators<br>(which we'll explore in session 4).<br>
These positions should be in the same container, with the first<br>before the second (or havoc will ensue).<br>
The vector class has member functions <b>begin() </b>and <b>end()</b>,<br>yielding positions as the start and end of the vector.<br>
So the above statement sorts the whole vector ­ a common idiom,<br>but using iterators is more general.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
19 / 25<br>
<hr>
<A name=20></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Where is the median?<br>
There are two cases:<br>
odd number of elements, e.g. 9:<br>
0<br>
1<br>
2<br>
3<br>
<b>4</b><br>
5<br>
6<br>
7<br>
8<br>
<b>v</b><br>
middle element is cell 4, i.e. <b>v[v.size()/2]</b><br>
even number of elements, e.g. 8:<br>
0<br>
1<br>
2<br>
<b>3</b><br>
<b>4</b><br>
5<br>
6<br>
7<br>
<b>v</b><br>
In this case we average the two middle elements (cells 3 and 4):<br>
<b>(v[v.size()/2 - 1] + v[v.size()/2])/2</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
20 / 25<br>
<hr>
<A name=21></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Computing the median<br>
We use this plan to compute the median of the sorted array:<br>
<b>// find the middle value</b><br>
<b>vector&lt;double&gt;::size_type middle = n/2;</b><br>
<b>double median;</b><br>
<b>if (n%2 == 1) // size is odd</b><br>
<b>median = v[middle];</b><br>
<b>else // size is even</b><br>
<b>median = (v[middle-1] + v[middle])/2;</b><br>
<b>cout &lt;&lt; &quot;median = &quot; &lt;&lt; median &lt;&lt; '\n';</b><br>
and our program is complete.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
21 / 25<br>
<hr>
<A name=22></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Type definitions<br>
A <b>typedef </b>declaration allows us to introduce a new name for a type:<br>
<b>typedef vector&lt;double&gt;::size_type vec_size;</b><br>
This defines a new type name <b>vec_size </b>that is equivalent to the<br>longer name. One use is to avoid repeating a long type name:<br>
<b>vec_size n = v.size();</b><br>
<b>// ...</b><br>
<b>vec_size middle = n/2;</b><br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
22 / 25<br>
<hr>
<A name=23></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Vectors: further points<br>
A vector variable contains a whole vector:<br>
<b>vector&lt;int&gt; v1 = v; // copy the vector</b><br>
<b>sort(v.begin(), v.end());</b><br>
results in <b>v </b>being sorted, but <b>v1 </b>still containing a copy of the<br>original unsorted <b>v</b>.<br>
When indexing <b>v[i]</b>, the index <b>i </b>is not checked: if it is out of<br>range, the program may crash or continue with corrupted data.<br>
Other vector member functions:<br>
back() returns the last element of the vector<br>
pop back() removes the last element of the vector<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
23 / 25<br>
<hr>
<A name=24></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Another container: <b>deque</b><br>
Deques (double-ended queues) can be created in a similar way:<br>
<b>deque&lt;int&gt; d; // an empty deque</b><br>
Deques support indexing with <b>[]</b>, and these member functions:<br>
size() the number of elements in the deque<br>
push back(x) add <b>x </b>to the back of the deque<br>
back() returns the last element of the deque<br>
pop back() removes the last element of the deque<br>
push front(x) add <b>x </b>to the front of the deque<br>
front() returns the first element of the deque<br>
pop front() removes the first element of the deque<br>
There are common names with <b>vector</b>, but no inheritance.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
24 / 25<br>
<hr>
<A name=25></a>Session 2 ­ Sequential containers<br>
Example: computing medians<br>
Next week<br>
Functions in C++ allow us to structure and reuse code.<br>
Passing parameters by value (like in Java) involves copying, which<br>can be expensive as in C++ (unlike in Java) variables contain<br>whole objects.<br>
Passing parameters by reference avoids copying, and is heavily<br>used in C++.<br>
It is good practice to use <b>const </b>qualifiers to declare that you're<br>not changing something.<br>
Ross Paterson (City, University of London)<br>
IN2029: Programming in C++<br>
Autumn term, 2018<br>
25 / 25<br>
<hr>
<A name="outline"></a><h1>Document Outline</h1>
<ul><li>Session 2  Sequential containers
<ul><li>Example: computing averages
<li>Example: computing medians
</ul></ul><hr>
</BODY>
</HTML>
