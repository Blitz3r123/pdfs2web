<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture1 - Introduction<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<A name=2></a><b>Credit where credit is due</b><br>
§ The slides and material for this module have been <br>
evolving over the years. Some are brand new and <br>some are adapted/adopted from previous years <br>and/or previous module leaders at City.<br>
2<br>
<hr>
<A name=3></a><b>What this module is about</b><br>
An abstract approach to programming as:<br>§ organising information (<i>data structures</i>)<br>§ performing computation (<i>algorithms</i>)<br>
Essential for computing professionals:<br>§ knowledge of common <i>data structures </i>and <i>algorithms<br></i>§ knowledge of when and how to use them<br>§ ability to analyse and develop them<br>
3<br>
<hr>
<A name=4></a><b>Context</b><br>
Builds on concepts from...<br>§ Computation and Reasoning<br>
§ Algorithms<br>§ Complexity analysis<br>
§ Systems Architecture<br>
§ How the operating systems handle programs execution<br>
§ Programming<br>
§ Describing algorithms<br>§ Executing algorithms<br>
Provides the basis for...<br>
§ Any work relying on the creation and/or modification of programs<br>
4<br>
<hr>
<A name=5></a><b>Learning Objectives</b><br>
§ Explain the workings of standard data structures and <br>
algorithms<br>
§ Analyse the space and time complexity of algorithms<br>§ Identify the most important abstract data types and the ways <br>
in which they may be implemented<br>
§ Select appropriate data structures and algorithms for <br>
particular practical situations<br>
§ Describe an implementation using plain English or <br>
pseudocode<br>
§ Devise appropriate algorithms to address specific problems<br>
5<br>
<hr>
<A name=6></a><b>How to reach the learning goals</b><br>
§ Work continuously<br>§ Attend the lectures (arrive on time!)<br>§ Go to the tutorials and do the exercises<br>§ Use interactive examples<br>§ Program the algorithms yourself<br>§ Work through all the exercises<br>§ Read the relevant sections in the textbook<br>§ Do additional exercises<br>
6<br>
<hr>
<A name=7></a><b>Course Text</b><br>
Weiss, Mark Allen: <i>Data Structures &amp; Problem Solving using <br>Java (4th edition). </i>Pearson Addison-Wesley, 2014<br>
...or, alternatively,<br>
Drozdek, Adam: Data Structures and Algorithms in Java (4th<br>edition).  Cengage 2013<br>
Earlier editions will do fine, and other books on data structures <br>and algorithms will help, too.<br>
7<br>
<hr>
<A name=8></a><b>Organisation<br></b>Module Lecturer: Aravin Naren <br>
&lt;aravin.naren.1@city.ac.uk&gt;  <br>
Office hours: A302 (College Building)<br>
usual y Thu 15:00-16:50 <br>
check on-line (via Moodle) for potential changes<br>Lectures: 2 hours / week<br>
Thursdays; 9:00 - 10:50 in A130<br>
Tutorial/Lab: 1 hour / week<br>
Leaving 120 hours for reading, coursework preparation, etc...<br>
Material on Moodle, with discussion board for mutual help<br>
8<br>
<hr>
<A name=9></a><b>Exercises</b><br>
Exercise sheets wil  be available on Moodle every week. The exercises <br>wil  be the topic of the tutorials.<br>
On even weeks wil  include a programming exercise.<br>
Doing the exercises is <b>essential </b>in preparing for the assessments.<br>
9<br>
<hr>
<A name=10></a><b>Questions &amp; Discussion</b><br>
Discussion forum on Moodle<br>
§ We read it frequently and reply/comment as appropriate<br>Asking specific questions<br>
§ Moodle, tutorials, lectures, TAs surgeries and module leader's office <br>
hours<br>
Note that Moodle wil  also be used for announcements<br>
10<br>
<hr>
<A name=11></a><b>Assessment</b><br>
Formative:<br>
§ 3 Multiple Choice Quizzes in weeks 3, 5 and 7<br>Summative:<br>
§<br>
Oral exam (viva) late in the term based on lectures and tutorials, <br>worth 30% of overal  marks<br>
§<br>
Written open books exam in January, worth 70% of overal  marks<br>
11<br>
<hr>
<A name=12></a><b>Feedback</b><br>
Tutorials<br>
§ Formative feedback, but you must do the exercises first<br>Quizzes<br>
§ Formative feedback online via Moodle<br>Viva<br>
§ Immediately, face to face<br>Exam<br>
§ Observations on general performance via Moodle<br>
12<br>
<hr>
<A name=13></a><b>2016-2017 Year Results</b><br>
Overal<br>
§<br>
135 ful y enrol ed by exam time<br>
§<br>
92 passed 1st attempt (68%)<br>
§<br>
26 passed resit (another 19%)<br>
§<br>
4 failed resit (3% of students)<br>
§<br>
14 did not attempt the resit (another 10%)<br>
13<br>
<hr>
<A name=14></a><b>2017-2018 Year Results</b><br>
Overal<br>
§<br>
149 ful y enrol ed by exam time<br>
§<br>
130 passed 1st attempt (87%)<br>
14<br>
<hr>
<A name=15></a><b>Some input from previous students</b><br>
Advice for new students<br>
§<br>
Practice on examples (tutorials and exercises) and seek feedback<br>
Advantages of the module<br>
§<br>
Real world applicability<br>
§<br>
Thought provoking<br>
§<br>
Connection to other modules<br>
§<br>
Important for job interviews<br>
Changes over the years<br>
§<br>
Changed some slides &amp; reshuffled some of the material<br>
§<br>
Made the link to programming more explicit<br>
§<br>
Made MCQs formative<br>
§<br>
Changed the exam format<br>
15<br>
<hr>
<A name=16></a><b>Rules of Engagement</b><br>
§ Fol ow the student charter<br>
§ Do NOT disturb others during the lectures<br>
§ If you are more than FIVE minutes late to the lecture, then wait <br>
for the break to come in<br>
§ Don't use your mobile phones, Ipods, etc.<br>
§ Keep them off or silent mode<br>
§ Don't hold paral el conversations during the lectures<br>
§ Do give us constructive feedback off line as we are moving along<br>
§ We wil  fol ow the University rules<br>
§ We wil  strive to give you the best learning experience possible<br>
16<br>
<hr>
<A name=17></a><b>Synopsis</b><br>
§<br>
Revisit intro to algorithms, pseudocode, time and space complexity<br>
§<br>
Recursion<br>
§<br>
Pointers<br>
§<br>
Abstract data types<br>
§ Priority queues, heaps, stacks, queues<br>§ Linked lists<br>
§ Singly linked lists, doubly linked lists and circular lists<br>
§<br>
Hash tables<br>
§<br>
Advanced trees<br>
§<br>
Graphs<br>
17<br>
<hr>
<A name=18></a><b>Week 1: Basic Concepts</b><br>
18<br>
<hr>
<A name=19></a><b>Basic Concepts</b><br>
§ What are Algorithms and Data Structures?<br>
§ Describing an algorithm<br>§ Properties of algorithms<br>
§ Data structure: static arrays<br>§ Algorithm type: search<br>
19<br>
<hr>
<A name=20></a><b>Data Structures and Algorithms*</b><br>
<b>System</b><br>
Representation<br>
Algorithms<br>
Data structures<br>
Task<br>
Reality<br>
20<br>
* See Computation &amp; Reasoning lecture notes<br>
<hr>
<A name=21></a><b>Algorithms in Computing</b><br>
Mathematical description of actions on numbers or symbols.<br>§ can be executed by a machine<br>§ are easily accessible to analysis<br>
We will look at the abstract properties of algorithms, understanding how <br>they work and using a bit of mathematics to determine how they behave.<br>
21<br>
<hr>
<A name=22></a><b>Describing an Algorithm</b><br>
§<br>
As unstructured text<br>
§<br>
As structured text<br>
§<br>
As a flow chart<br>
§<br>
As pseudocode<br>
§<br>
As Java code (or any programming language)<br>
In this module we will mainly use pseudocode and Java.<br>
22<br>
<hr>
<A name=23></a><b>Pseudocode Syntax*</b><br>
Title with function/method name and <br>arguments<br>
Sequence control in capitals:<br>
<i>Function foo(array):</i><br>
­ WHILE<br>
<i>bar </i>¬ <i>0, i </i>¬ <i>1</i><br>
­ IF/THEN/ELSE<br>
<i>WHILE i &lt;= length of array</i><br>
<i>bar </i>¬ <i>bar+ array[i]</i><br>
Indent to indicate scope<br>
<i>i </i>¬ <i>i + 1</i><br>
Arrow for assignment (can <br>
<i>Return bar</i><br>
be typed "&lt;-")<br>
23<br>
* See Computation &amp; Reasoning lecture notes<br>
<hr>
<A name=24></a><b>Another Example</b><br>
Title with function/method name and <br>arguments<br>
<i>Function foo2(array):<br>bar </i>¬ <i>0, i </i>¬ <i>1</i><br>
Sequence control in capitals:<br>
<i>WHILE i &lt;= length of array</i><br>
­ WHILE<br>
<i>IF array[i] = 0 THEN</i><br>
­ IF/THEN/ELSE<br>
<i>bar </i>¬ <i>bar + 1</i><br>
<i>ELSE</i><br>
Indentation indicates scope<br>
<i>array[i] </i>¬ <i>0</i><br>
<i>i </i>¬ <i>i + 1</i><br>
Arrow for assignment (can <br>
<i>Return bar</i><br>
24<br>
be typed as "&lt;-")<br>
<hr>
<A name=25></a><b>Data Structures</b><br>
Data structures are ways of organising data.<br>
They should<br>§ represent all relevant information<br>§ use little memory<br>§ support efficient algorithms<br>
25<br>
<hr>
<A name=26></a><b>A simple data structure: a static array</b><br>
§ Built into most programming languages<br>§ A finite set of elements<br>§ The elements are in a fixed sequence<br>§ Elements can be addressed by <br>indices (Pseudocode, Mathematics, Pascal) or offsets (Java, C, C++)<br>
26 3<br>
7 13 9<br>
5 17 4<br>
index<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
offset<br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
26<br>
<hr>
<A name=27></a><b>Devising programmes to solve problems</b><br>
... is a combination of identifying the most suitable<br>
§<br>
data structure to contain the data<br>
§<br>
algorithm to accomplish the task <br>
§<br>
Not all combinations of data structures and algorithms work<br>
§<br>
A given combination of data structure and algorithm may be ideal for <br>one situation, yet not the best for another<br>
27<br>
<hr>
<A name=28></a><b>An algorithm example</b><br>
What does <i>foo </i>do? *<br>
<i>Function foo(array):<br>bar </i>¬ <i>0, i </i>¬ <i>1<br>WHILE i &lt;= length of array</i><br>
<i>bar </i>¬ <i>bar+ array[i]<br>i </i>¬ <i>i + 1</i><br>
<i>Return bar</i><br>
* From slide 23<br>
28<br>
<hr>
<A name=29></a><b>Another algorithm example</b><br>
What does <i>foo2 </i>do? *<br>
<i>Function foo2(array):<br>bar </i>¬ <i>0, i </i>¬ <i>1<br>WHILE i &lt;= length of array</i><br>
<i>IF array[i] = 0 THEN</i><br>
<i>bar </i>¬ <i>bar + 1</i><br>
<i>ELSE</i><br>
<i>array[i] </i>¬ <i>0</i><br>
<i>i </i>¬ <i>i + 1</i><br>
<i>Return bar</i><br>
* From slide 23<br>
29<br>
<hr>
<A name=30></a><b>Known algorithm examples</b><br>
§ Selection sort<br>§ Insertion sort<br>§ Quicksort<br>§ Mergesort<br>§ Binary search<br>
Ø Why were these examples explored?<br>
* Seen on Computation &amp; Reasoning<br>
30<br>
<hr>
<A name=31></a><b>Computational Complexity</b><br>
31<br>
<hr>
<A name=32></a><b>Computational Complexity</b><br>
Description of the resources needed by an algorithm:<br>§ Complexity in <br>
§ (running) time or<br>§ (memory) space<br>
§ Best, worst and average cases<br>§ Representation by growth<br>
32<br>
<hr>
<A name=33></a><b>Formalism for big-O</b><br>
DEFINITION: <i>f(n) </i>is in <i>O(g(n)) </i>if and only if <i>c </i>and <i>N&gt;0 </i>exist such that for all <i>n <br>&gt; N</i>, <i>f(n) </i> <i>c</i>· <i>g(n)<br>c </i>is a constant factor, and <i>N </i>is an index of asymptotic behaviour.<br>Example: <i>f(n)=2n2 + 3n + 1 </i>is in <i>O(n2)</i>:<br><i>N=2 </i>and <i>c=4</i>, or <i>N=4 </i>and <i>c=3</i>, etc.<br>Property: if <i>f1(n) </i>and <i>f2(n) </i>are both in <i>O(g(n))</i>, so is <i>f1(n)+f2(n)<br></i>Proof (sketch): Let <i>c1</i>, <i>c2 </i>be the constant factors for <i>f1 and f2, then with c1+2 = c1<br>+ c2 apply big-O definition.</i><br>
33<br>
<hr>
<A name=34></a><b>Implications...</b><br>
§ Big-O is an upper bound, actual values may be less<br>
§ If <i>g</i>(<i>n</i>) <i> f(n) </i>then <i>g</i>(<i>n</i>) is in O(<i>f(n))</i><br>
§ Saying that an algorithm <i>a </i>is in O(<i>g</i>(<i>n</i>)) means that it grows no faster than <br>
<i>g</i>(<i>n</i>).<br>
Note: We often omit the word 'in' and say <i>a </i>is O(<i>g</i>(<i>n</i>)).<br>
34<br>
<hr>
<A name=35></a><b>Properties of big-O</b><br>
Rule 1: Scaling by a constant: <i>O(c·f(n)) = O(f(n))</i><br>
Rule 2: Addition: <br>
if <i>f(n) </i>is <i>O(g(n)) (always applies to one part)</i><br>
then <i>O(f(n)) + O(g(n)) = O(g(n)) </i>(greater term dominates)<br>
<i>Rule 3: Multiplication:</i><br>
<i>O(f(n))·O(g(n)) = O(f(n)·g(n))</i><br>
<i>Rule 4: Logarithms: </i><br>
<i>O(loga n) = O(logb n) </i>(we usual y just write <i>O(log n)</i>)<br>
35<br>
<hr>
<A name=36></a><b>Example calculations</b><br>
§Orders of sequential algorithm phases are added:<br>
e.g. an <i>O(n2) </i>phase followed by an <i>O(n log (n)) </i>phase is <br>
<i>O(n2) + O(n log(n)) = O(n2)</i><br>
§(<i>n log(n)) is O(n2)</i>, apply Rule 2)<br>
§3n log(n) + 100n + 50log(n) + 23  is  <i>...</i><br>
36<br>
<hr>
<A name=37></a><b>Example calculations (2)</b><br>
§ Orders of nested loops are multiplied:<br>
e.g. an outer loop is executed <i>O(n2) </i>times and contains an inner loop that <br>
is executed <i>O(n) </i>times (its content is O(1)): <br>
O(n2)·O(n) = O(n3)  <br>
Rule 3<br>
§ 3n log(n) · 2n + 7log(n)  is  <i>...</i><br>
37<br>
<hr>
<A name=38></a><b>Common types of complexity *</b><br>
constant: <i>O(1)<br></i>logarithmic: <i>O(log n) </i><br>
<i><b>good</b></i><br>
linear: <i>O(n)<br></i>quadratic: <i>O(n2)</i><br>
<i><b>acceptable </b>(sometimes)</i><br>
cubic: <i>O(n3)<br></i>polynomial: <i>O(nk)<br></i>exponential: <i>O(an)</i><br>
<i><b>intractable</b></i><br>
<i>factorial: O(n!)</i><br>
* See Computation &amp; Reasoning lecture notes<br>
38<br>
<hr>
<A name=39></a><b>Sequential search is linear</b><br>
O(n)<br>
<i>number <br>of loops</i><br>
<i>array length</i><br>
39<br>
<hr>
<A name=40></a><b>Binary search is logarithmic: O(log n)</b><br>
<i>log(n)+1<br>worst case</i><br>
<i>average</i><br>
<i>loops</i><br>
40<br>
<i>array length</i><br>
<hr>
<A name=41></a><b>Binary search is logarithmic: O(log n)</b><br>
<i>log(n)+1</i><br>
<i>loops</i><br>
<i>worst</i><br>
<i>average</i><br>
<i>array length</i><br>
41<br>
<i>Note how flat the graph gets for large numbers.</i><br>
<hr>
<A name=42></a><b>Finding the order of complexity</b><br>
<i>Function binary_search(array, key)<br>lo </i>1<i>, hi  length of array<br>WHILE lo  hi</i><br>
<i>mid  (lo + hi) / </i>2<br><i>IF key &lt; array[mid] THEN</i><br>
<i>hi = mid - </i>1<br>
<i>ELSE</i><br>
<i>IF key &gt; array[mid] THEN</i><br>
<i>lo = mid + </i>1<br>
<i>ELSE</i><br>
<i>Return mid</i><br>
<i>Return </i>-1<br>
42<br>
<hr>
<A name=43></a><b>Examples of code complexity analysis</b><br>
<i>Function foo3(array):<br>sum  </i>0<i>, c  </i>1<br><i>WHILE c &lt;= length of array</i><br>
<i>c1  </i>1<br><i>WHILE c1 &lt;= length of array</i><br>
<i>sum  sum + array[c] * </i><br>
<i>array[c1]</i><br>
<i>c1  c1 + </i>1<br>
<i>c  c + </i>1<br>
<i>Return sum</i><br>
43<br>
<hr>
<A name=44></a><b>Other examples of complexity code analysis *</b><br>
<i>Function foo(array):<br>bar </i>¬ <i>0, i </i>¬ <i>1<br>WHILE i &lt;= length of array</i><br>
<i>bar </i>¬ <i>bar+ array[i]<br>i </i>¬ <i>i + 1</i><br>
<i>Return bar</i><br>
44<br>
* From slides 22 and 27<br>
<hr>
<A name=45></a><b>Other examples of complexity code analysis *</b><br>
<i>Function foo2(array):<br>bar </i>¬ <i>0, i </i>¬ <i>1<br>WHILE i &lt;= length of array</i><br>
<i>IF array[i] = 0 THEN</i><br>
<i>bar </i>¬ <i>bar + 1</i><br>
<i>ELSE</i><br>
<i>array[i] </i>¬ <i>0</i><br>
<i>i </i>¬ <i>i + 1</i><br>
<i>Return bar</i><br>
45<br>
* From slides 23 and 28<br>
<hr>
<A name=46></a><b>Some algorithms and their complexity</b><br>
· Binary search: O(log n) time, O(1) space <br>
<b>fast</b><br>
· Linear search: O(n) time, O(1) space<br>· Multiplication of n-bit integers: O(n log n log log n) <b>doable<br></b>· Matrix multiplication for n*n matrices (std): O(n3)<br>· Travelling salesman: Best known algorithms take<br>
O(2n) time <br>
<b>intractable</b><br>
· All permutations of a sequence: O(n!)<br>
46<br>
<hr>
<A name=47></a><b>Well known complexity classes</b><br>
P: computable in polynomial time<br>§ these problems are considered tractable (although there are limits in practice).<br>
NP: computable in polynomial time on a non-deterministic (infinitely parallel) <br>machine<br>§ if we can take a solution and test it in polynomial time, we can find any solution <br>
by testing all possible solutions in parallel<br>
EXPTIME: exponential time<br>§ these problems are known to be really hard.<br>
47<br>
<hr>
<A name=48></a><b>NP-Complete Problems</b><br>
Class of combinatorial problems that are equally hard; e.g.:<br>§ Travelling salesman problem:<br>
Shortest tour visiting all cities in a set<br>
§ Knapsack:<br>
Given a set of items with a given value and weight each,<br>find the set with the highest value within a weight limit<br>
§ Satisfiability:<br>
Find the assignment of values to make a logical proposition true<br>
Any NP problem can be reduced to any of these, i.e. if we have a solution to one <br>of them we have one to all NP.<br>
48<br>
<hr>
<A name=49></a><b>Famous Question: Is P = NP?</b><br>
One of the 6 Millennium Prize Problems<br>US $1 million offered for a solution by<br>Clay Mathematics Institute, Massachusetts.<br>
If there is an polynomial solution to an NP-complete problem, then P = NP.<br>No solution found yet, but also no proof that it is impossible.<br>
Most scientists believe P != NP. Otherwise some very hard problems will become <br>easy (possibly including some cryptographic code-breaking). Some solutions have <br>been presented, but none has stood up to scrutiny yet.<br>
49<br>
<hr>
<A name=50></a><IMG src="lecture1Introduction-50_1.jpg"><br>
Grigori Perelman<br>
50<br>
<hr>
<A name=51></a><b>Reading</b><br>
§ For visualisations check Linear and Binary Search on:<br>
https://www.cs.usfca.edu/~galles/visualization/Search.html<br>
§ Weiss:  Chapter 5 <br>
§ Drozdek:  Chapter 2 <br>
Next week: Recursion &amp; Abstract Data Types<br>
51<br>
<hr>
<A name=52></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
52<br>
<hr>
</BODY>
</HTML>
