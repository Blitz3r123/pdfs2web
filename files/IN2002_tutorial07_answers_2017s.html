<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>Module IN2002--Data Structures and Algorithms </b><br>
<b>Exercise Sheet 7 </b><br>
 <br> <br>1. Write out a preorder, inorder, postorder and breadth-first traversals of the following binary <br>tree: <br> <br>
6<br>
11<br>
17<br>
15<br>
13<br>
12<br>
16<br>
1<br>
9<br>
3<br>
8<br>
2<br>
7<br>
10<br>
 <br>
 <br>Indicate the contents of the node visited and the stack/queue at each point in the preorder, <br>inorder, postorder and breadth-first traversals. <br> <br> <br> <br>
  Preorder:     // visit the node, traverse left, then traverse right; use stack to keep track of <br>
nodes to visit given the order of the recursive calls <br>
 <br>
Node visited <br>
Stack <br>
 <br>
6 <br>
6 <br>
11  17 <br>
11 <br>
15  17 <br>
15 <br>
16  1  17 <br>
16 <br>
1  17 <br>
1 <br>
8  17 <br>
8 <br>
17 <br>
17 <br>
13  12 <br>
13 <br>
9  12 <br>
9 <br>
2  12 <br>
2 <br>
12 <br>
12 <br>
3 <br>
3 <br>
7  10 <br>
7 <br>
10 <br>
10 <br>
 <br>
 <br> <br> <br>
 <br>
<hr>
<A name=2></a>  Inorder:     // traverse left, visit node, then traverse right; use stack to keep track of nodes <br>
to visit given the order of the recursive calls <br>
 <br>
Node visited <br>
Stack <br>
 <br>
16  15  11  6 <br>
16 <br>
15  11  6 <br>
15 <br>
8  1  11  6 <br>
8 <br>
1  11  6 <br>
1 <br>
11  6 <br>
11 <br>
6 <br>
6 <br>
9  13  17 <br>
9 <br>
2  13  17 <br>
2 <br>
13  17 <br>
13 <br>
17 <br>
17 <br>
7  3  12 <br>
7 <br>
3  12 <br>
3 <br>
10  12 <br>
10 <br>
12 <br>
12 <br>
 <br>
 <br> <br> <br>
  Postorder:      // traverse left, traverse right, then visit the node; use stack to keep track of <br>
nodes to visit given the order of the recursive calls <br>
 <br>
Node visited <br>
Stack <br>
16 <br>
15L  11L  6L <br>
8 <br>
1L  15R  11L  6L <br>
1 <br>
15R  11L  6L <br>
15 <br>
11L  6L <br>
11 <br>
6L <br>
2 <br>
9R  13L  17L  6R <br>
9 <br>
13L  17L  6R <br>
13 <br>
17L  6R <br>
7 <br>
3L  12L  17R  6R <br>
10 <br>
3R  12L  17R  6R <br>
3 <br>
12L  17R  6R <br>
12 <br>
17R  6R <br>
17 <br>
6R <br>
6 <br>
 <br>
 <br> <br>
 <br>
<hr>
<A name=3></a>  Breadth-first:     // visit one level at a time (left to right); use a queue to keep track of <br>
nodes to visit. <br>
 <br>
Node visited <br>
Queue <br>
 <br>
6 <br>
6 <br>
11  17 <br>
11 <br>
17  15 <br>
17 <br>
15  13  12 <br>
15 <br>
13  12  16  1 <br>
13 <br>
12  16  1  9 <br>
12 <br>
16  1  9  3 <br>
16 <br>
1  9  3 <br>
1 <br>
9  3  8 <br>
9 <br>
3  8  2 <br>
3 <br>
8  2  7  10 <br>
8 <br>
2  7  10 <br>
2 <br>
7  10 <br>
7 <br>
10 <br>
10 <br>
 <br>
 <br> <br>2. Write a recursive function that reverses the order of the nodes in each level of a binary tree. <br> <br>
void reverse(TreeNode t) { <br>
if (t != null) { <br>
tmp = t.left; <br>t.left = t.right; <br>t.right = tmp; <br>reverse(t.left); <br>reverse(t.right); <br>
} <br>
} <br>
 <br> <br> <br>3. Write a non-recursive function using a stack to compute the size of a binary tree. <br> <br> <br>
  Any traversal could be adapted by creating a counter and adding 1 to it each time a node <br>
is visited. The exercise asks for an iterative function using stacks, so preorder or inorder <br>would be appropriate.  <br>
 <br>
  Using the preorder function: <br>
 <br>
int iterativeSize(TreeNode p) { <br>
int count = 0; // we create the counting variable <br>if (p != null){ <br>
Stack stack = new StackImpl(); <br>stack.push(p); <br>do { <br>
p = (TreeNode)stack.pop(); <br>
<hr>
<A name=4></a>count ++; // we add 1 when we visit <br>if (p.right != null) <br>
stack.push(p.right); <br>
if (p.left != null) <br>
stack.push(p.left); <br>
} while (! stack.isEmpty()); <br>
} <br>return count; // return the count <br>
  } <br> <br> <br>4. Show the binary search tree that results from inserting the following sequence of keys: 6, <br>3, 11, 9, 8, 5, 4, 2, 12, 7, 1, 10. <br> <br>
  The first element (6) is added at the root, and any subsequent elements are added by <br>
following the left branch when their value is lower than the root, or the right branch <br>when it is greater. For example, the last element added was (10), which is larger than <br>6; so the right branch is followed and 11 is found. 10 is lower than 11, so the left <br>branch is followed and 9 is found. 10 is greater than 9 and nothing is in 9's right <br>branch, so then we place 10 there. <br>
6<br>
3<br>
11<br>
2<br>
5<br>
9<br>
12<br>
1<br>
4<br>
8<br>
10<br>
7<br>
 <br>
 <br> <br>5. What kind of tree is produced if the same keys are inserted in ascending order? What if <br>they are inserted in descending order? <br> <br>
  By placing the keys in order (ascending or descending), a "backbone" tree is <br>
produced. For example, in ascending order: <br>
<hr>
<A name=5></a>1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
...<br>
 <br>
 <br> <br>
 <br>
<hr>
<A name=6></a>6. A possible sorting algorithm is to add all the keys of an array to a binary search tree and <br>then read off its inorder traversal. Is this related to any of the sorting algorithms previously <br>considered? <br> <br>
  When adding keys to the binary tree, what is being done can be seen as finding a <br>
pivot, placing it at the root, and partitioning the rest by placing the values lower than <br>the root to the left, and the values larger than the root to the right. A pivot is found for <br>each one of these subtrees and a similar partitioning process takes place. The <br>procedure is thus similar to what quicksort does. <br>
 <br> <br>7. Show the tree that results from the tree built in exercise 4 if you delete10? What if you <br>deleted 3 instead? <br> <br>
  Removing a leaf node is easy: the element is simply deleted. <br>
 <br>
6<br>
3<br>
11<br>
2<br>
5<br>
9<br>
12<br>
1<br>
4<br>
8<br>
7<br>
 <br>
 <br>
  To remove the 3, some procedure should be followed. Since the 3 has the two <br>
branches, the "harder case" of deletion seen in the lecture is applied: <br>
 <br>
6<br>
4<br>
11<br>
2<br>
5<br>
9<br>
12<br>
1<br>
8<br>
10<br>
7<br>
 <br>
 <br>
<hr>
<A name=7></a>  As you may have realised, this is not the only possible way of doing the deletion. In <br>
your textbooks you may find other possible algorithms that will, for example, place <br>the 2 where the 3 was, and have the (5) subtree. <br>
 <br>
<hr>
</BODY>
</HTML>
