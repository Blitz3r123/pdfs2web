<html><head><title>Title</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"></head><body><p class="lead">
<a name="1"></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 2 &#xFFFD; Recursion and Abstract Data Types<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<a name="2"></a><b>Learning Objectives</b><br>
&#xFFFD; Understand recursive algorithms<br>
&#xFFFD; What it means for an algorithm to be recursive<br>&#xFFFD; How to analyse a recursive algorithm in terms of time and space <br>
complexities<br>
&#xFFFD; Abstract data types <br>
&#xFFFD; What they are<br>&#xFFFD; How they are implemented<br>
2<br>
<hr>
<a name="3"></a><b>Recursion</b><br>
3<br>
<hr>
<a name="4"></a><b>Divide and Conquer</b><br>
Many algorithms have the form:<br>
&#xFFFD;If the input is not simple, <b>divide </b>the input into simpler <br>
components, apply the algorithm recursively to each part, and <br><b>combine </b>the results obtained<br>
&#xFFFD;Otherwise, <b>solve </b>it with a special algorithm<br>
4<br>
<hr>
<a name="5"></a><b>Analysing divide and conquer algorithms</b><br>
You have to consider, for an input size of <i>n</i>:<br>
&#xFFFD;If the input is simple<br>
&#xFFFD; the time the special algorithm takes<br>
&#xFFFD;Otherwise, <br>
&#xFFFD; the time of dividing the input, plus<br>&#xFFFD; the time of processing the components, plus<br>&#xFFFD; the time of combining the results<br>&#xFFFD; ... and then solve the recursive definition.<br>
5<br>
<hr>
<a name="6"></a><b>Recursion *</b><br>
A powerful way of programming using a function within itself<br>&#xFFFD; A problem is addressed by identifying:<br>
&#xFFFD; A step towards the next simpler case to which the same <br>
approach applies<br>
AND<br>
&#xFFFD; Result in the simplest case<br>
&#xFFFD; Recursion is, in a way, the reverse of proof by induction<br>
6<br>
* Introduced to you in Computation &amp; Reasoning<br>
<hr>
<a name="7"></a><b>Example: Factorial<br></b>Problem: calculate <i>n</i>! = <i>n</i>&#xFFFD;(<i>n</i>-1)&#xFFFD;(<i>n</i>-2)&#xFFFD;...&#xFFFD;1<br>&#xFFFD; Step (for <i>n</i>&gt;0): <i>n</i>! = <i>n</i>&#xFFFD;(<i>n</i>-1)!<br>&#xFFFD; Base (simplest) case: 0! = 1<br>This defines the value of n! for any natural number n.<br>
<i>Function factorial(n)<br>IF n = 0 THEN</i><br>
// 0<br>
<i>Return 1</i><br>
// 1<br>
<i>ELSE</i><br>
// 2<br>
<i>aux  factorial(n-1)</i><br>
// 3<br>
<i>Return n * aux</i><br>
// 4<br>
7<br>
<hr>
<a name="8"></a>n     aux<br>
<i>Function factorial(n) </i>0<br>
<i>IF n = 0 THEN                     // 0</i><br>
<b>What is going on?</b><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
Cal ing factorial (2)<br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
1<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
2<br>
2<br>
2<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
8<br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<hr>
<a name="9"></a>n     aux<br>
<i>Function factorial(n) </i>0<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<b>What is going on? (2)</b><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3<br>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
<i>Function factorial(n)</i><br>
1<br>
1<br>
1<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
Returns 2<br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
n     aux<br>
n     aux<br>
<i>Function factorial(n)</i><br>
n     aux<br>
<i>Function factorial(n)</i><br>
2<br>
2<br>
1<br>
<i>Function factorial(n) </i>2<br>
1<br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>IF n = 0 THEN                     // 0</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>Return 1                     // 1</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>ELSE                                  // 2</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
<i>aux  factorial(n-1)  // 3</i><br>
9<br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<i>Return n * aux          // 4</i><br>
<hr>
<a name="10"></a><b>Understanding the Picture</b><br>
&#xFFFD; Recursive calls to factorial get pushed onto the stack<br>
&#xFFFD; Multiple copies of function factorial, each with different <br>
arguments &amp; local variable values, and execution at <br>different lines of the code<br>
&#xFFFD; All the computer really needs to remember for each active <br>
function call is the values of arguments &amp; local variables <br>and the location of the next statement to be executed when <br>control goes back <br>
10<br>
<hr>
<a name="11"></a><b>The Stack</b><br>
n   aux  line<br>
0<br>
0<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
1<br>
0<br>
1<br>
3<br>
1<br>
1<br>
3<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
n   aux  line<br>
2<br>
0<br>
2<br>
3<br>
2<br>
3<br>
2<br>
3<br>
2<br>
1<br>
3<br>
11<br>
<hr>
<a name="12"></a><b>What are &quot;factorial&apos;s&quot; the time and space <br>complexities?  </b><br>
&#xFFFD; Time complexity<br>
&#xFFFD; Calls itself n times<br>&#xFFFD; All other statements constant<br>&#xFFFD; ... hence O(??)<br>
&#xFFFD; Space complexity <br>
&#xFFFD; Calls itself n times (stack)<br>&#xFFFD; ... hence O(??)<br>
12<br>
<hr>
<a name="13"></a><b>Example: power<br></b>Problem: calculate <i>xn<br></i>&#xFFFD; Step (for <i>n&gt;0</i>): <i>xn = x &#xFFFD; xn-1<br></i>&#xFFFD; Base case: <i>x0 = 1<br></i>This defines the value of <i>xn </i>for any natural number <i>n</i>.<br>
<i>Function power(x, n):<br>IF n = 0 THEN</i><br>
<i>Return 1</i><br>
<i>ELSE</i><br>
<i>Return x * power(x, n-1)</i><br>
13<br>
<hr>
<a name="14"></a><b>What are &quot;power&apos;s&quot; the time and space <br>complexities?  </b><br>
&#xFFFD; Time complexity<br>
&#xFFFD; Space complexity<br>
14<br>
<hr>
<a name="15"></a><b>Tail Recursion</b><br>
void tail(int i) {<br>
if (i &gt; 0) {<br>
Tail recursion is when the <br>
System.out.println(i);<br>
recursive call is the last thing <br>
tail(i-1);<br>
done.<br>
}<br>
}<br>
void tailloop(int i) {<br>
while (i &gt; 0) {<br>
A loop can easily replace it.<br>
System.out.println(i);<br>i=i-1;<br>
}<br>
15<br>
}<br>
<hr>
<a name="16"></a><b>Example of Tail Recursion: factorial</b><br>
<i>This factorial function is tail-recursive:</i><br>
int factorial(int n) {<br>
return fact(n, 1);<br>
}<br>
int fact (int n, int product) {<br>
if (n == 0){<br>
return product;<br>
}<br>return fact(n-1, n*product);<br>
}<br>
16<br>
<hr>
<a name="17"></a><b>... Tail Recursive factorial</b><br>
int fact (int n, int product) {<br>
if (n == 0)<br>
return product;<br>
return fact(n-1, n*product);<br>
}<br>
<i>And can easily be converted </i><br>
int fact(int n, int product) {<br>
<i>into iterative (i.e. a loop).</i><br>
while(n&gt;0) {<br>
product = n*product;<br>n = n-1;<br>
}<br>return product;<br>
}<br>
17<br>
<hr>
<a name="18"></a><b>Another Example of Recursion</b><br>
What does this function do?<br>
void printNum(int n) {<br>
if (n &gt;= 10){<br>
printNum(n/10);<br>
}<br>System.out.print(n%10);<br>
}<br>
18<br>
<hr>
<a name="19"></a><b>A Call Tree for printNum</b><br>
printNum(1234)<br>
printNum(123)<br>
printNum(12)<br>
printNum(1)<br>
System.out.print(`1&apos;)<br>
System.out.print(`2&apos;)<br>
System.out.print(`3&apos;)<br>
System.out.print(`4&apos;)<br>
19<br>
<hr>
<a name="20"></a><b>What are &quot;printNum&apos;s&quot; the time and space <br>complexities?</b><br>
&#xFFFD; Time complexity<br>
&#xFFFD; Calls itself log n times<br>&#xFFFD; All other statements constant<br>&#xFFFD; ... hence O(??)<br>
&#xFFFD; Space complexity <br>
&#xFFFD; Calls itself log n times (stack)<br>&#xFFFD; ... hence O(??)<br>
20<br>
<hr>
<a name="21"></a><b>Another example for recursion (exam 2014-15)</b><br>
<b>Recursion   </b>(15%)<br>You are given the code for <i>bla </i>below. <br>
void bla (int i)  {<br>
if (i &gt; 0) {<br>
System.out.print (i + &quot; &quot;);<br>bla(i &#xFFFD; 1);<br>
}<br>
}<br>
21<br>
<hr>
<a name="22"></a><b>Another example for recursion (exam 2014-15) &#xFFFD;<br>cont&apos;d</b><br>
a) Describe what <i>bla </i>does.  (5%)<br>
b) What is its time complexity? Justify your answer.  (5%)<br>
c) What is its space complexity? Justify your answer.  (5%)<br>
22<br>
<hr>
<a name="23"></a><b>Applications of Recursion</b><br>
Recursion is useful for:<br>
&#xFFFD; designing algorithms<br>&#xFFFD; traversing branching structures (like trees and graphs)<br>&#xFFFD; writing parsers<br>&#xFFFD; backtracking search algorithms<br>&#xFFFD; divide-and-conquer algorithms<br>
23<br>
<hr>
<a name="24"></a><b>Pros and Cons of Using Recursion</b><br>
&#xFFFD;Pros<br>
&#xFFFD;often elegant solutions<br>
&#xFFFD;compact code<br>
&#xFFFD;proving correctness often relatively easy<br>
&#xFFFD;Cons<br>
&#xFFFD;careful algorithm design necessary<br>
&#xFFFD;hard to debug (better prove correctness)<br>
&#xFFFD;function call stack needs extra memory and is often limited<br>
24<br>
<hr>
<a name="25"></a><b>Common Computations</b><br>
&#xFFFD; Why do we often discuss sorting algorithms?<br>
&#xFFFD; How about searching?<br>
&#xFFFD; Insertion?<br>
&#xFFFD; Deletion?<br>
25<br>
<hr>
<a name="26"></a><b>Sorting Algorithms</b><br>
&#xFFFD; What are examples of sorting algorithms?<br>
&#xFFFD; How fast are they?<br>
26<br>
<hr>
<a name="27"></a><b>Sorting Algorithms</b><br>
<b>Space </b><br>
<b>Average time  Worst case </b><br>
<b>complexity</b><br>
<b>complexity</b><br>
<b>time <br>complexity</b><br>
Selection sort O(1)<br>
O(n2)<br>
O(n2)<br>
Insertion sort<br>
O(1)<br>
O(n2)<br>
O(n2)<br>
Quicksort<br>
O(log n)<br>
O(n log n)<br>
O(n2)<br>
Mergesort<br>
O(n)<br>
O(n log n)<br>
O(n log n)<br>
27<br>
<hr>
<a name="28"></a><b>Other Common Computations</b><br>
&#xFFFD; How about searching?<br>
&#xFFFD; Insertion?<br>
&#xFFFD; Deletion?<br>
28<br>
<hr>
<a name="29"></a><b>Deletion Algorithm</b><br>
&#xFFFD; How do we delete an element of an array?<br>
&#xFFFD; What if the array is sorted?<br>
&#xFFFD; How often do we need to delete new elements?<br>
29<br>
<hr>
<a name="30"></a><b>Food for Thought</b><br>
&#xFFFD; Should we always use arrays to store and manipulate our data? <br>
&#xFFFD; Should we always sort their contents?<br>
30<br>
<hr>
<a name="31"></a><b>Abstract Data Types</b><br>
31<br>
<hr>
<a name="32"></a><b>Abstract Data Types  (ADTs)</b><br>
&#xFFFD;Abstract data types<br>
&#xFFFD;separate functionality from implementation<br>
&#xFFFD;hidden representation<br>&#xFFFD;manipulated via a limited set of operations<br>&#xFFFD;in Java, interfaces with defined method semantics<br>
&#xFFFD;Data structures<br>
&#xFFFD;concrete implementations, often subject to an invariant preserved by <br>the operations<br>&#xFFFD;in Java: classes implementing ADT interfaces<br>&#xFFFD;are analysed by measuring the time and space complexity of  the <br>structure and each  operation<br>
32<br>
<hr>
<a name="33"></a><b>ADT Stack</b><br>
Think of physical stacks:<br>
&#xFFFD; series of similar elements<br>&#xFFFD; you add elements on the top<br>&#xFFFD; you take the elements from the top<br>
... so the last element in is the first out (LIFO)<br>
33<br>
<hr>
<a name="34"></a><b>Stack Operations</b><br>
You can only remove the last element added.<br>
The operations are thus:<br>
&#xFFFD; Add an element to the stack<br>&#xFFFD; Remove the last element added<br>&#xFFFD; Check whether the stack is empty.<br>
34<br>
<hr>
<a name="35"></a><b>A stack in Java</b><br>
// a stack of integers<br>public interface Stack {<br>
// is the stack empty?<br>boolean isEmpty();<br>
// add (push) an element into the stack<br>void push(int elt);<br>
// remove and return the most recently pushed<br>// element still in the stack<br>int pop();<br>
35<br>
}<br>
<hr>
<a name="36"></a><b>A stack implementation using an array</b><br>
<i>public class ArrayStack implements Stack {</i><br>
<i>private int[] a;<br>private int count = 0;</i><br>
<i>public ArrayStack(int size) {a = new int[size];}</i><br>
<i>public boolean isEmpty() { return count == 0; }</i><br>
<i>public void push(int elt) { a[count++] = </i><br>
<i>elt; }</i><br>
<i>public int pop() { return a[--count]; }</i><br>
<i>}</i><br>
36<br>
<hr>
<a name="37"></a><b>Checking Brackets with a Stack</b><br>
opening bracket:  push on stack<br>closing bracket: pop from stack and match<br>
String <br>
Stack<br>
Op<br>
( [ ] ( [ ) ] )<br>
push<br>
[ ] ( [ ) ] ) <br>
( <br>
push<br>
] ( [ ) ] )<br>
( [ ) ] )<br>
[ ) ] )<br>
) ] )<br>
37<br>
<hr>
<a name="38"></a><b>Priority Queues</b><br>
&#xFFFD; You can only remove the element with the highest priority<br>&#xFFFD; Examples: printer queues, emergency rooms, council housing<br>
38<br>
<hr>
<a name="39"></a><b>Priority Queue Operations</b><br>
&#xFFFD; Add an element<br>&#xFFFD; Remove an element: the element removed is the one with <br>
the highest priority<br>
&#xFFFD; Check whether the queue is empty<br>
39<br>
<hr>
<a name="40"></a><b>Applications of Priority Queues</b><br>
&#xFFFD; As a component of various algorithms<br>&#xFFFD; Sorting: add all the items to the priority queue and then <br>
extract them one by one<br>
&#xFFFD; Scheduling (e.g. in operating systems, post, air traffic)<br>&#xFFFD; Event-driven simulation<br>
40<br>
<hr>
<a name="41"></a><b>Scheduling</b><br>
Several tasks should be performed with different priorities<br>For example...<br>
We want to produce a system for parcel deliveries. The priority could be <br>set by using the guaranteed date of delivery and the time at which the <br>parcel was posted.<br>
&#xFFFD; The priority queue would be handled by storing the parcels in the depot <br>
and releasing them for delivery according to their priority.<br>
&#xFFFD; In busy days, probably only those parcels whose delivery is due - i.e., <br>
those that have the highest priority - could be delivered.<br>
&#xFFFD; In less busy days, parcels would be delivered in advance of their <br>
41<br>
guaranteed date of delivery.<br>
<hr>
<a name="42"></a><b>Event-Driven Simulation</b><br>
<i>We wish to simulate a series of events, each considered to occur at a point in </i><br>
<i>simulated time.</i><br>
Nothing happens between events, so maintain a collection of pending events, and repeat:<br>
&#xFFFD; extract the first pending event<br>
&#xFFFD; advance the simulation clock to its time<br>
&#xFFFD; simulate the event<br>
Events may change the state, and may cause other events at later times, i.e. add further <br>
events to the collection<br>
Useful for load analysis and prediction<br>
e.g., for Internet nodes, road or air traffic, emergency procedures.<br>
42<br>
<hr>
<a name="43"></a><b>A priority queue ADT</b><br>
// A priority queue of integers<br>public interface PriorityQueue {<br>
// Is the priority queue empty?<br>boolean isEmpty();<br>
// Add an element to the priority queue<br>void add(int elt);<br>
// Remove and return the largest value<br>// currently in the priority queue<br>int extractMax();<br>
}<br>
43<br>
<hr>
<a name="44"></a><b>An implementation using a sorted array</b><br>
<i>A way of implementing priority queues is to keep the elements <br>in a sorted array, so:</i><br>
&#xFFFD; <i>to add an element, search and insertion are used<br></i>&#xFFFD; <i>to extract an element, the last element in the array is </i><br>
<i>extracted (as it will have the highest priority)</i><br>
44<br>
<hr>
<a name="45"></a><b>Concrete Implementation in Java</b><br>
public class ArrayPQ implements PriorityQueue {<br>
private int[] data;<br>private int count = 0;<br>
public ArrayPQ(int size){ data = new int[size]; }<br>
public boolean isEmpty(){ return count == 0; }<br>
public void add(int elt){<br>
insert(data, count++, elt);<br>
}<br>
public int extractMax(){ return data[--count]; }<br>
45<br>
}<br>
<hr>
<a name="46"></a><b>Analysing the use of the Data Structure</b><br>
&#xFFFD; The data structure takes O(n) space complexity<br>
&#xFFFD; By using the ordered array data structure:<br>
&#xFFFD; isEmpty takes time O(??)<br>&#xFFFD; add takes time O(??)<br>&#xFFFD; extractMax takes time O(??)<br>
&#xFFFD; The ordering constraint is very restrictive, maintaining it by <br>
insertions costs O(n) time.<br>
46<br>
<hr>
<a name="47"></a><b>An Alternative Implementation</b><br>
What would happen if the representation were an unordered array?<br>
In that case:<br>
&#xFFFD; isEmpty takes time O(??)<br>&#xFFFD; add takes time O(??)<br>&#xFFFD; extractMax takes time O(??)<br>
It is an equivalent situation, but slow at extracting.<br>
47<br>
<hr>
<a name="48"></a><b>Is there a better implementation?</b><br>
48<br>
<hr>
<a name="49"></a><b>Reading</b><br>
&#xFFFD; Weiss: Chapter 7, and chapter 15 section 1.1  <br>
&#xFFFD; Drozdek: Chapter 5, and chapter 4 sections 4.1and 4.3  <br>
Next week: Trees and heapsort<br>
49<br>
<hr>
<a name="50"></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
50<br>
<hr>


</p></body>