<html><head><title>Title</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"></head><body><p class="lead">
<a name="1"></a><b>IN2002 Data Structures and Algorithms </b><br>
Lecture 4 &#xFFFD; Pointers and Singly Linked Lists<br>
Aravin Naren<br>Semester 1, 2018/19<br>
1<br>
<hr>
<a name="2"></a><b>Learning Objectives</b><br>
&#xFFFD;Understand and be able to use the data structure <br>singly linked lists<br>&#xFFFD; Be able to understand, apply and develop <br>algorithms to handle singly linked lists. Including:<br>
&#xFFFD;Adding elements<br>
&#xFFFD;Deleting elements <br>
&#xFFFD;Traversing a list<br>
2<br>
<hr>
<a name="3"></a><b>Introduction</b><br>
3<br>
<hr>
<a name="4"></a><b>What is this?</b><br>
5<br>
8<br>
3<br>
null<br>
4<br>
<hr>
<a name="5"></a><b>Database Records</b><br>
&#xFFFD;A record is a fixed col ection of things of different types.<br>&#xFFFD;E.g. records at a mobile phone provider:<br>
Client ID <br>
1234<br>
Phone number <br>
+44 7887 4444444<br>
Owner <br>
Rupert Taylor<br>
Start date <br>
04/10/2001<br>
Credit <br>
&#xFFFD;24.53<br>
Type of contract  Ultra<br>International opt. No<br>Free minutes left  42<br>
5<br>
<hr>
<a name="6"></a><b>Records as Objects</b><br>
class Mobile {<br>
public int clientID;<br>public String number;<br>public String name;<br>public Date startdate;<br>public int credit;<br>public char contract;<br>public boolean intl;<br>public int seconds;<br>...<br>public Mobile(int id, String nu, String na, ...) {<br>
clientID = c; number = nu; name = na; ....<br>
}<br>
6<br>
}<br>
<hr>
<a name="7"></a><b>Pointers to Records</b><br>
&#xFFFD; In Java, variables cannot contain objects (record instances, <br>in this case), but pointers to them<br>&#xFFFD; Every reference type can have value nul , which refers to no <br>object at all<br>
Mobile x = null;<br>
&#xFFFD; Several variables may refer to the same object:<br>
Mobile y = new Mobile(1234,<br>
&quot;+44 7887 4444444&quot;,&quot;Rupert&quot;,...);<br>
Mobile z = y;<br>
7<br>
<hr>
<a name="8"></a><b>Are two records equal?</b><br>
Consider:<br>
Mobile x = new Mobile(1234,<br>
&quot;+44 7887 4444444&quot;,&quot;Rupert&quot;,...);<br>
Mobile y = new Mobile(1234,<br>
&quot;+44 7887 4444444&quot;,&quot;Rupert&quot;,...);<br>
Mobile z = x;<br>
x == z is <br>x == y is<br>
x.compareTo(y), however, can be defined to return 0 to indicate that <br>both objects contain the same values<br>
8<br>
<hr>
<a name="9"></a><b>What would happen here?</b><br>
Consider:<br>
Mobile x = new Mobile(1234,<br>
&quot;+44 7887 4444444&quot;,&quot;Rupert&quot;,...);<br>
Mobile y = new Mobile(1234,<br>
&quot;+44 7887 4444444&quot;,&quot;Rupert&quot;,...);<br>
Mobile z = x;<br>z.name = &quot;Anne&quot;;<br>y.clientID = 555;<br>
What are the values of:<br>x.name <br>
x.clientID<br>
y.name <br>
y.clientID<br>
9<br>
z.name <br>
z.clientID<br>
<hr>
<a name="10"></a><b>What are links? </b><br>
All object variables in Java are actually pointers<br>
A pointer is a link to some object, i.e. a piece of memory:<br>
&#xFFFD; Links can be thought of as arrows, addresses or references<br>&#xFFFD; They point at an object that is somewhere in the system&apos;s memory<br>
10<br>
<hr>
<a name="11"></a><b>Pointers to an address</b><br>
Foo p;<br>
When you create and assign objects, the system <br>
<b>null</b><br>
al ocates memory and assigns addresses<br>
Foo p = new Foo();<br>
memory <b>address E1E42FB:</b><br>
<b>E1E42FB</b><br>
New object of <br>class Foo<br>
Foo q = p;<br>
Creating a pointer to the same object <br>
<b>E1E42FB</b><br>
at address  <b>E1E42FB</b><br>
11<br>
<hr>
<a name="12"></a><b>Pointers are links</b><br>
Foo p;<br>
In Java you don&apos;t need to worry about the <br>
<b>null</b><br>
address, just what you are pointing at.<br>
Foo p = new Foo();<br>
memory address <b>E1E42FB:</b><br>
New object of <br>class Foo<br>
Foo q = p;<br>
In official Java parlance, they are cal ed <br><i>references</i>.<br>
12<br>
<hr>
<a name="13"></a><b>Links in Java</b><br>
<b>All </b>variables whose type is a class (or interface) of objects are actually <br>pointers (&quot;references&quot;) to an instance of such class (or to null if empty).<br>
This means that the <b>same </b>object can be assigned to different variables<br>
... and, importantly, the same object&apos;s methods and parameters can be <br>accessed through different variables<br>
13<br>
<hr>
<a name="14"></a><b>Singly Linked Lists</b><br>
14<br>
<hr>
<a name="15"></a><b>Singly linked lists</b><br>
How do you remove a value from the middle of an array?<br>How would you do it in real life, e.g. in a long written list?<br>In real life, to add something at the middle of a long list what do you do?<br>How would you do it with arrays?<br>
Singly linked lists use pointers as links to the next element in the list.<br>
15<br>
<hr>
<a name="16"></a><b>Nodes in singly linked lists</b><br>
Each node contains a value and a pointer to the next node:<br>public class Node {<br>
public int info;<br>
info<br>
public Node next;<br>
next<br>
...<br>
}<br>
Node h;<br>
5<br>
8<br>
3<br>
null<br>
16<br>
<hr>
<a name="17"></a><b>A node implementation in a singly linked list</b><br>
public class Node {<br>
public int info;<br>public Node next;<br>
public Node(int i, Node n) {<br>
info = i; next = n;<br>
}<br>
public Node(int i) {<br>
this(i, null);<br>
}<br>
}<br>
17<br>
<hr>
<a name="18"></a><b>Adding elements at the head of a list</b><br>
Node h<br>
Node h = null;<br>
null<br>
Node h<br>
3<br>
h = new Node(3);<br>
null<br>
Node h<br>
h = new Node(8,h);<br>
8<br>
3<br>
null<br>
Node h<br>
h = new Node(5,h);<br>
5<br>
8<br>
3<br>
null<br>
18<br>
<hr>
<a name="19"></a><b>Adding elements at the tail</b><br>
Node h<br>
Node h = null;<br>
null<br>
Node h<br>
5<br>
h = new Node(5);<br>
null<br>
Node h<br>
h.next = new Node(8);<br>
5<br>
8<br>
null<br>
Node h<br>
h.next.next = new Node(3);<br>
5<br>
8<br>
3<br>
null<br>
19<br>
<hr>
<a name="20"></a><b>Pointers to the head and tail</b><br>
Adding elements at the tail is faster1 if we keep a  pointer to the last <br>element (if any). We define a new class to hold the head and tail pointers:<br>
SLList<br>Node head;<br>Node tail;<br>
5<br>
8<br>
3<br>
null<br>
1. Faster than adding elements at the tail while having only a pointer to the <br>head.<br>
20<br>
<hr>
<a name="21"></a><b>The singly linked list class</b><br>
public class SLList {<br>
private Node head = null;<br>private Node tail = null;<br>
public boolean isEmpty() {<br>
return head == null;<br>
}<br>
public void addToHead(int el) <br>
{...}<br>
public void addToTail(int el) { ... }<br>
public int deleteFromHead() {...}<br>
}<br>
21<br>
<hr>
<a name="22"></a><b>Special cases</b><br>
An empty list:<br>
SLList<br>Node head;<br>
null<br>
Node tail;<br>
null<br>
A list with one element:<br>
SLList<br>Node head;<br>Node tail;<br>
5<br>
null<br>
22<br>
<hr>
<a name="23"></a><b>What shouldn&apos;t happen in singly linked lists</b><br>
&#xFFFD; Loops<br>&#xFFFD; Errors with pointers, e.g.<br>
tail does not point to head.next. ... .next<br>
&#xFFFD; Tail node with non-null pointer<br>&#xFFFD; Non-tail node with null pointer<br>
23<br>
<hr>
<a name="24"></a><b>Operations in singly linked lists</b><br>
&#xFFFD; Adding an element at the head<br>&#xFFFD; Adding an element at the tail<br>&#xFFFD; Deleting the head element<br>&#xFFFD; Deleting the tail element<br>
24<br>
<hr>
<a name="25"></a><b>Adding an element at the head</b><br>
There are two cases:<br>
&#xFFFD; The list contains at least one element<br>
(so the tail stays the same)<br>
&#xFFFD; The list is empty (head = tail = nul )<br>
(we need to set the tail)<br>
public void addToHead(int el) {<br>
head = new Node(el, head);<br>if(tail == null)<br>
tail = head;<br>
}<br>
25<br>
<hr>
<a name="26"></a><b>Adding an element at the tail</b><br>
Two cases again:<br>
&#xFFFD; If the list is empty, we need to set the head<br>&#xFFFD; Otherwise, we need to set the pointer of the old tail<br>
public void addToTail(int el) {<br>
if (! isEmpty()) {<br>
tail.next = new Node(el);<br>tail = tail.next;<br>
}<br>else<br>
head = tail = new Node(el);<br>
}<br>
26<br>
<hr>
<a name="27"></a><b>Deleting the head element</b><br>
SLList<br>Node head;<br>Node tail;<br>
Just move the<br>head pointer:<br>
5<br>
8<br>
3<br>
null<br>
(Special case:<br>head == tail<br>
SLList<br>Node head;<br>
-&gt;<br>
Node tail;<br>
head = nul ;<br>tail = nul ;)<br>
5<br>
8<br>
3<br>
null<br>
27<br>
<hr>
<a name="28"></a><b>Deleting the head element (2)</b><br>
If the list has more than one element, change the head<br>Otherwise, make the list empty<br>
public int deleteFromHead() {<br>
int el = head.info;<br>if(head == tail) // one or no elements<br>
head = tail = null;<br>
else<br>
head = head.next;<br>
return el;<br>
}<br>
28<br>
<hr>
<a name="29"></a><b>Deleting the last element </b><br>
We need to set tail to the second last node<br>... but it&apos;s more easily said than done:<br>
if(head == tail) // one or no elements<br>
head = tail = null;<br>
else <br>
aux = sll.head<br>while (aux.next!=tail)<br>
aux = aux.next<br>
aux.next = null<br>sll.tail = aux<br>
29<br>
<hr>
<a name="30"></a><b>Traversing a list  </b><br>
1<br>
2<br>
3<br>
null<br>
Function printList()<br>aux = sll.head<br>While (aux! = null)<br>
print aux.info<br>aux = aux.next<br>
... so to traverse the list, iteratively (or recursively!) evaluate <br>the rest of the list (i.e., next)<br>
30<br>
<hr>
<a name="31"></a><b>Applications of singly linked lists  </b><br>
&#xFFFD; A list requires O(n) space<br>&#xFFFD; The operations we have defined each take O(1) time<br>&#xFFFD; Lists can represent the following ADTs:<br>
&#xFFFD; Stack uses <br>
&#xFFFD; for push  <br>&#xFFFD; for pop <br>
&#xFFFD; Queue uses<br>
&#xFFFD; for enqueue   <br>
&#xFFFD; for dequeue   <br>
&#xFFFD; Lists may also be used directly in many algorithms<br>&#xFFFD; Important high-level programming languages strongly rely on linked lists <br>
(e.g., Lisp)<br>
31<br>
<hr>
<a name="32"></a><b>Other uses?  </b><br>
It is possible to implement priority queues, stacks, queues and heaps using <br>linked lists. However, is this efficient?<br>
Let us have a closer look:<br>
&#xFFFD; priority queues: inserting a new element in a sorted singly linked list takes O(?)<br>&#xFFFD; heaps: searching a parent or child in a singly linked list is O(?)<br>
32<br>
<hr>
<a name="33"></a><b>Some observations</b><br>
&#xFFFD; Extensible arrays efficiently implement the Stack ADT, as well as the <br>
array operations, overhead for additional space<br>
&#xFFFD; Singly linked lists:<br>
&#xFFFD; efficiently implement the Stack and Queue ADTs, and have many other uses<br>&#xFFFD; can only move in one direction, accessing elements in the middle or rear part is <br>
difficult<br>
&#xFFFD; incur overhead for the pointers<br>
33<br>
<hr>
<a name="34"></a><b>Reading</b><br>
&#xFFFD; Weiss: Chapter 15 (Stacks and Queues), and section 16.1 and 16.2 <br>
(Linked Lists)  <br>
&#xFFFD; Drozdek: Sections 1.4 (Java and Pointers), 3.1 (Singly Linked Lists), 4.1 <br>
(Stacks) and 4.2 (Queues)  <br>
Next week: Circular lists and Doubly linked lists<br>
Drozdek: sections 3.2 (doubly linked lists) and 3.3 (circular lists) OR Weiss: <br>
section 16.3 (doubly linked lists and circular lists)<br>
34<br>
<hr>
<a name="35"></a>City, University of London<br>Northampton Square<br>London<br>EC1V 0HB<br>United Kingdom<br>
T: +44 (0)20 7040 8406<br>E: ug-compsci@city.ac.uk<br>www.city.ac.uk/department-computer-science<br>
35<br>
<hr>


</p></body>