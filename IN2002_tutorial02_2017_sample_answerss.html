<html><head><title>Title</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"></head><body><p class="lead">
<a name="1"></a><b>Module IN2002--Data Structures and Algorithms </b><br>
<b>Sample Answers to Exercise Sheet 2 </b><br>
 <br> <br>
 <br>
 <br>
1. The function power presented in the lecture is rather inefficient. Use the equations: <br> <br>
<i>x2n = xn &#xFFFD;xn <br>x2n+1 = x&#xFFFD;xn&#xFFFD;xn </i><br>
 <br>to write a more efficient <b>recursive </b>algorithm. How much time does the new version take? <br> <br>/** <br>* Calculate x^n more efficiently. <br>* @param x The base. <br>* @param n The exponent (must not be negative). <br>*/ <br>double power(double x, int n) { <br>
if (n == 0) <br>
return 1.0; <br>
double p = power(x, n/2); // p=x^(n/2) int division! <br>p *= p; // p = x^(n-n%2) <br>if (n%2 != 0) // odd n needs one more factor <br>
p *= x; // p = x^n <br>
return p; <br>
} <br> <br>
  The call tree for this function looks like this: <br>
 <br>
power(x, n) <br>
power(x, n/2) <br>
power(x, n/4) <br>
... <br>
 <br>
and this will have depth log n. As the function without the recursive call takes constant time, <br>the whole function takes O(log n) time. To achieve this, it is crucial that   we   call <br>power(x, n/2) only once and store its value in p to use the result twice. In other words: <br>using power(n, n/2) * power(n, n/2) makes it O(<i>n</i>) again. <br> <br> <br> <br>2. Consider the function: <br> <br>
<i>int sumOfSquares(int n) { </i><br>
<i>if (n == 0) </i><br>
<i>return 0; </i><br>
<i>return n*n + sumOfSquares(n-1); </i><br>
<i>} </i><br>
 <br>Is it tail recursive? Can you convert it to iterative? If so, how? If not, why not? <br>
<hr>
<a name="2"></a>  This function computes the sum n2 + ... + 22 + 12 and takes time O(n). <br>
 <br>
  The last call the function makes is n*n + sumOfSquares(n-1). The function is not tail <br>
recursive because the last call it makes is to operator `+&apos; rather than the recursive call <br>&quot;sumOfSquares&quot;. <br> <br>
  The same function can be expressed as tail recursive by creating an auxiliary function: <br>
 <br>int sumOfSquares(int n) { <br>
return sos(n, 0); <br>
} <br>int sos(int n, int sum) { <br>
if (n==0) <br>
return sum; <br>
return sos(n-1, n*n + sum); <br>
} <br> <br> <br>
  This version can be easily converted to iterative: <br>
 <br>int sumOfSquares(int n) { <br>
int sum = 0; <br>for ( ; n&gt;0; n-=1) <br>
sum = n*n + sum; <br>
return sum; <br>
} <br> <br>
  A skilled programmer can of course convert the original version to iterative, too, <br>
using a stack. But for a tail-recursive function it works easily without a stack. <br>
 <br> <br>
 <br>
3. The array priority queue implementation provided in the lecture notes assumed a sorted <br>array, where the method <i>add </i>contains a call to a method <i>insert</i>. Provide the algorithm for the <br>method <i>insert</i> (pseudocode or a programming language are fine). <br> <br>void insert(array data, int size, int element) { <br>
int position  1; <br>// find the position in the array where the new element <br>// needs to be added <br>WHILE (position &lt; size AND data[position] &lt; element) <br>
position++; <br>
// move all larger existing elements up one position <br>int inPlace  size <br>WHILE (inPlace &gt; position) <br> <br>
data[inPlace]  data[inPlace-1]; <br>
 <br>
inPlace--; <br>
// insert the new element in its correct place <br>data[position]  element; <br>
} <br>
<hr>
<a name="3"></a>  Note that finding the position here has been done using sequential search. It could <br>
also have been done using binary search. That would have improved the time <br>complexity of the first loop, but not of the second. Hence, the overall complexity <br>would remain unchanged. <br>
 <br> <br> <br>4. Had the priority queue been implemented using an unsorted array, there would be some <br>differences to the implementation of its basic operations (<i>isEmpty</i>, <i>add</i>, <i>extractMax</i>). Discuss <br>which of these would need to be changed and why, while providing new algorithms for those <br>requiring changes (again, pseudocode or a programming language are fine). <br> <br>
  isEmpty remains the same, as what really matters is simply whether there are any <br>
elements in the array or not. <br>
  add would be faster and changed, as we would simply add the new element to the end <br>
of the existing array. <br>
 <br>void add(int elt) { <br>
count++; <br>data[count]  elt; <br>
} <br> <br>
  extractMax would be slower and changed, as we would need to traverse the whole <br>
array keeping track of the largest value found so far and its position. Then remove that <br>element and reshuffle all other elements that were in the array in positions after it, <br>actually removing the largest element. <br> <br>
int extractMax() { <br>
int largest  data[1] <br>int position  1 <br>int i  1 <br>// find largest value and its position <br>WHILE i &lt; count <br> <br>
i++ <br>
 <br>
IF largest &lt; data[i] <br>
 <br>
 <br>
largest  data[i] <br>
 <br>
 <br>
position  i <br>
// reshuffle other elements <br>i  position <br>WHILE i &lt; count <br> <br>
data[i]  data[i+1] <br>
 <br>
i++ <br>
count-- <br>Return largest <br>
} <br>
 <br> <br> <br>
<hr>
<a name="4"></a><b>And a bit of programming. You are not expected to tackle this during the tutorial slot, <br>but at some later time, at your own convenience. Note that answers to this will be <br>released much later than for the other questions, giving you time to experiment with it. <br> <br></b>5. A cocktail shaker sort designed by Donald Knuth is a modification of bubble sort in which <br>the direction of bubbling changes in each iteration: In one iteration, the smallest element is <br>bubbled up; in the next, the largest is bubbled down; in the next, the second smallest is <br>bubbled up; and so forth. Implement the new algorithm and discuss its complexity. <br>
 <br>
<b>And a bit of programming. Answers to this will be released much later, giving you time <br>to experiment with it. </b><br>
 <br> <br> <br> <br>
<b>Refresher Powers and Logs (justify your answers)  <br></b>// TO BE USED FOR REVISION OUTSIDE THE TUTORIAL <br> <br>6. What is 23  (2 power 3)? <br>
a) 9  <br>
  No, 9 = 3*3 = 32 <br>
b) 6  <br>
  No, 6=2*3 <br>
c) 8  <br>
  Yes, 8 = 2*2*2 = 23 <br>
d) 5 <br>
  No, 5=2+3 <br>
 <br>
7. What is the log2 16  (logarithm of 16 base 2)? <br>
a) 1  <br>
  No, 21 = 2, 1 = log 2 2  (or log 2 base 2) <br>
b) 2  <br>
  No, 22 = 2*2 = 4, 2 = log 2 4  (or log 4 base 2) <br>
c) 3  <br>
  No, 23 = 2*2*2 = 8, 3 = log 2 8  (or log 8 base 2) <br>
d) 4 <br>
  Yes, 24 = 2*2*2*2 = 16, 4 = log 2 16  (or log 16 base 2) <br>
 <br>8. What is the log4 16  (logarithm of 16 base 4)? <br>
a) 1  <br>
  No, 41=4, 1 = log 4 4   (or log 4 base 4) <br>
b) 2  <br>
  Yes, 42 = 4*4 = 16, 2 = log 4 16   (or log 16 base 4) <br>
c) 3  <br>
  No, 43 = 4*4*4 = 64, 3 = log 4 64    (or log 64 base 4) <br>
d) 4 <br>
  No, 44 = 4*4*4*4 = 256, 4 = log 4 256    (or log 256 base 4) <br>
 <br>
 <br>
<hr>


</p></body>