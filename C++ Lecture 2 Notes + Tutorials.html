<html><head><title>Title</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"></head><body><div style="width: 50%; margin-left: 25%; text-align: center;"><p class="lead">
<a name="1"></a>Session 2<br>
Sequential containers<br>
Example: computing averages<br>
This session<br>
We&apos;ll be writing some programs that operate on batches of data, which allows us to explore<br>
&#xFFFD; a bit more about streams<br>
&#xFFFD; the standard idiom for looping to the end of an input stream<br>
&#xFFFD; manipulators<br>
&#xFFFD; vectors from the standard template library<br>
&#xFFFD; introduction to containers<br>
Calculating statistics from a list of numbers<br>
Task: read in a list of numbers and print their average.<br>The overall structure of our program will be:<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;iomanip&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>// ... read in data ...</b><br>
<b>// ... print results ...</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Reading the data<br>
The first part is to read all the numbers and record their count and sum:<br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
2.1<br>
<hr>
<a name="2"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.2<br>
<b>// the number and total of values read</b><br>
<b>int count = 0;</b><br>
<b>double sum = 0;</b><br>
<b>// read values from standard input</b><br>
<b>double x; // a variable for reading into</b><br>
<b>while (cin &gt;&gt; x) {</b><br>
<b>++count;</b><br>
<b>sum += x;</b><br>
<b>}</b><br>
Library details: testing for end-of-input<br>
We have already seen that the <b>&gt;&gt; </b>operator returns the input stream, in statements like<br>
<b>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</b><br>
But the result of <b>&gt;&gt; </b>can also be used in a test, as in the common idiom for reading a series of things<br>and testing for the end of the input:<br>
<b>while (cin &gt;&gt; x) {</b><br>
<b>// .. do something with x</b><br>
<b>}</b><br>
Testing a stream yields <b>true </b>if the last operation on the stream succeeded, and <b>false </b>if it didn&apos;t.<br>
(You can indicate end of input on the console by typing Control-Z Return on Windows, or Control-<br>
D on Unix.)<br>
Language details: <b>i++ </b>vs <b>++i</b><br>
The following statements all increase an <b>int </b>variable <b>i </b>by one:<br>
<b>i = i+1;</b><br>
<b>i += 1;</b><br>
<b>i++;</b><br>
<b>++i;</b><br>
The difference between the last two is only seen when the value of the expression is used:<br>
<b>int i = 5;</b><br>
<b>int j = ++i; // j is set to 6; i is now 6</b><br>
<b>int k = i++; // k is also set to 6; i is now 7</b><br>
&#xFFFD; <b>i++ </b>returns the value before incrementing (so the old value has to be saved somewhere, which<br>
could be expensive with some types)<br>
&#xFFFD; <b>++i </b>returns the value after incrementing (simpler)<br>
<hr>
<a name="3"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.3<br>
Printing the results<br>
Finally, we want to print the results:<br>
<b>cout &lt;&lt; count &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (count &gt; 0) {</b><br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; sum/count &lt;&lt; &apos;\n&apos;;</b><br>
<b>}</b><br>
By default, floating point numbers are printed with up to 5 significant figures, but we can change that:<br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; setprecision(3) &lt;&lt;</b><br>
<b>sum/count &lt;&lt; &apos;\n&apos;;</b><br>
Library details: manipulators<br>
<b>setprecision(3) </b>is an example of a stream manipulator (from the <b>&lt;iomanip&gt; </b>system<br>
header), like <b>flush </b>or <b>endl</b>: a special kind of object with an overloading of the <b>&lt;&lt; </b>operator than<br>changes the state of the stream.<br>
This manipulator is used to adjust formatting:<br>
<b>cout &lt;&lt; setprecision(3);</b><br>
doesn&apos;t do any output, but it sets the precision for any following output.<br>
<b>cout &lt;&lt; setprecision(3) &lt;&lt; x &lt;&lt;</b><br>
<b>setprecision(5) &lt;&lt; y;</b><br>
Other manipulators set base, paddings, etc.<br>
Cleaning up<br>
&#xFFFD; We have used <b>setprecision </b>to set the maximum number of decimal places to what we<br>
want.<br>
&#xFFFD; Nothing else is happening in this program, but in general it would be polite to set the precision<br>
back to what it was before.<br>
&#xFFFD; We can get the current precision using <b>cout.precision()</b>.<br>
This yields our final version:<br>
<b>int prec = cout.precision();</b><br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; setprecision(3) &lt;&lt;</b><br>
<b>sum/count &lt;&lt; setprecision(prec) &lt;&lt; &apos;\n&apos;;</b><br>
Breaking the input into words<br>
An example reading strings:<br>
<hr>
<a name="4"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.4<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;iomanip&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
<b>// the number and total of values read</b><br>
<b>int count = 0;</b><br>
<b>double sum = 0;</b><br>
<b>// read values from standard input</b><br>
<b>double x; // a variable for reading into</b><br>
<b>while (cin &gt;&gt; x) {</b><br>
<b>++count;</b><br>
<b>sum += x;</b><br>
<b>}</b><br>
<b>// output results</b><br>
<b>cout &lt;&lt; count &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (count &gt; 0) {</b><br>
<b>int old_prec = cout.precision();</b><br>
<b>cout &lt;&lt; &quot;average = &quot; &lt;&lt; setprecision(3) &lt;&lt;</b><br>
<b>sum/count &lt;&lt; setprecision(old_prec) &lt;&lt; &apos;\n&apos;;</b><br>
<b>}</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Figure 2.1: Complete average program<br>
<hr>
<a name="5"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.5<br>
<b>#include &lt;string&gt;</b><br>
<b>#include &lt;iostream&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>string s;</b><br>
<b>while (cin &gt;&gt; s)</b><br>
<b>cout &lt;&lt; s &lt;&lt; &apos;\n&apos;;</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Recall that the <b>&gt;&gt; </b>operator on strings reads words.<br>
Example: computing medians<br>
Calculating a different statistic<br>
Task: read in a list of numbers and print their median.<br>The median of a collection of numbers is the &quot;middle&quot; value when they are arranged in order:<br>
1 3 3 7 10 11 11 13 14 15 15<br>
However, the input data may be in any order.<br>
&#xFFFD; Unlike computing the average, to compute the median we will need to store all the numbers<br>
until the end of the program. We shall use a <b>vector </b>to do this.<br>
&#xFFFD; Then we need to arrange the values in order. We shall use the library function <b>sort</b>.<br>
&#xFFFD; Then the median will be the middle value in the vector.<br>
Outline<br>
The overall structure of our program will be:<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;vector&gt;</b><br>
<b>#include &lt;algorithm&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>// ... read and store the data ...</b><br>
<b>// ... sort the data ...</b><br>
<b>// ... print the middle value ...</b><br>
<b>return 0;</b><br>
<b>}</b><br>
<hr>
<a name="6"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.6<br>
Vectors<br>
<b>#include &lt;vector&gt;</b><br>
C++ has arrays, but we&apos;ll use vectors instead (a container like ArrayList in Java, except that a<br>variable of <b>vector </b>type holds an object, not a reference):<br>
<b>vector&lt;int&gt; vi;</b><br>
<b>// empty vector of ints</b><br>
<b>vector&lt;string&gt; vs;</b><br>
<b>// empty vector of strings</b><br>
Vectors also be extended:<br>
<b>vs.push_back(s);</b><br>
The current length of <b>vs </b>is <b>vs.size()</b><br>
Vectors can be accessed just like arrays (indices 0 . . . <b>size()-1</b>):<br>
<b>vi[1] = x;</b><br>
<b>vi[2] = vi[1] + 3;</b><br>
Syntax seems simple but the meaning is not. . .<br>
Expression &quot;<b>vi[1]</b>&quot; in Java would have to be written as &quot;vi.get(1)&quot;, where vi would have been<br>
declared instead as a reference to an ArrayList container.<br>
&#xFFFD; Thanks to operator overloading C++ allows us to type less (2 characters for &quot;<b>[]</b>&quot; instead of 6 characters<br>
for &quot;.get()&quot;.<br>
&#xFFFD; It also allows us to keep the syntax of arrays that we&apos;re familiar with and treat vectors as if they&apos;re<br>
advanced arrays (that we can extend/shorten).<br>
&#xFFFD; But this comes at a price &#xFFFD; the code is not as clear now as it was in Java. In Java it&apos;s obvious we&apos;re<br>
calling a function while in C++ it is not so obvious &#xFFFD; one has to remember that every use of an operator<br>is actually a function call in C++!<br>
&#xFFFD; So <b>vi[1] </b>is actually <b>vi.operator[](1)</b>.<br>
Reading the data into a vector<br>
We start by reading all the numbers and storing them in a vector:<br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
<b>// read numbers from the standard input</b><br>
<b>// and store them in a vector</b><br>
<b>vector&lt;double&gt; v;</b><br>
<b>double x;</b><br>
<b>while (cin &gt;&gt; x)</b><br>
<b>v.push_back(x);</b><br>
We don&apos;t need a separate variable to count them: we can use <b>v.size()</b>.<br>
<hr>
<a name="7"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.7<br>
Finding the median: outline<br>
&#xFFFD; Only a non-empty vector can have a median.<br>
&#xFFFD; First, we need to sort the vector.<br>
<b>// compute and output results</b><br>
<b>unsigned n = v.size();</b><br>
<b>cout &lt;&lt; n &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (n &gt; 0) {</b><br>
<b>// sort the whole vector</b><br>
<b>sort(v.begin(), v.end());</b><br>
<b>// ... find the middle value</b><br>
<b>}</b><br>
Language details: unsigned types<br>
C++ has signed and unsigned integral types of various sizes:<br>
Signed<br>
?<br>
Unsigned<br>
<b>signed char</b><br>
<b>char</b><br>
<b>unsigned char</b><br>
<b>short</b><br>
<b>unsigned short</b><br>
<b>int</b><br>
<b>unsigned int </b>(or <b>unsigned</b>)<br>
<b>long</b><br>
<b>unsigned long</b><br>
<b>long long</b><br>
<b>unsigned long long </b>(in C++11)<br>
&#xFFFD; Unlike in Java, the sizes are not defined by the standard (but they are non-decreasing).<br>
&#xFFFD; <b>char </b>may be either a signed or unsigned type, whichever is more efficient on this architecture.<br>
&#xFFFD; Unsigned types cannot be negative: if <b>i </b>is of unsigned type, <b>i &lt; 0 </b>can never be <b>true</b>.<br>
Unsigned types: caution<br>
&#xFFFD; Unsigned integers will silently underflow:<br>
<b>unsigned i = 0;</b><br>
<b>i -= 1;</b><br>
will not fail &#xFFFD; it will set <b>i </b>to a very large positive number.<br>
&#xFFFD; If an operation involves both a signed and unsigned type, it will silently convert the signed type<br>
to unsigned first, so in<br>
<b>int i = -5;</b><br>
<b>unsigned j = 1;</b><br>
<b>if (i &lt; j)</b><br>
the last test will fail, because <b>-5 </b>will be silently converted to a very large positive number.<br>
<hr>
<a name="8"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.8<br>
The type of <b>size()</b><br>
&#xFFFD; Containers cannot have negative size.<br>
&#xFFFD; The return type of the <b>size() </b>member function is an unsigned type, but which unsigned type<br>
is implementation dependent.<br>
&#xFFFD; The portable name of its type is <b>vector&lt;double&gt;::size_type</b>.<br>
&#xFFFD; Here <b>:: </b>selects a static attribute of the type <b>vector&lt;double&gt;</b>. (This is a different use of<br>
<b>:: </b>from namespace qualification, as in <b>std::vector</b>.)<br>
&#xFFFD; We can use this as the type of the variable <b>n</b>:<br>
<b>vector&lt;double&gt;::size_type n = v.size();</b><br>
Library details: <b>sort</b>, <b>begin</b>, <b>end</b><br>
<b>sort(v.begin(), v.end());</b><br>
&#xFFFD; To sort a vector, we use the <b>sort </b>function, declared in the <b>&lt;algorithms&gt; </b>system header.<br>
&#xFFFD; Instead of a container, <b>sort </b>takes two positions or iterators (which we&apos;ll explore in session 4).<br>
&#xFFFD; These positions should be in the same container, with the first before the second (or havoc will<br>
ensue).<br>
&#xFFFD; The vector class has member functions <b>begin() </b>and <b>end()</b>, yielding positions as the start<br>
and end of the vector.<br>
&#xFFFD; So the above statement sorts the whole vector &#xFFFD; a common idiom, but using iterators is more<br>
general.<br>
Where is the median?<br>
There are two cases:<br>
&#xFFFD; odd number of elements, e.g. 9:<br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
<b>v</b><br>
middle element is cell 4, i.e. <b>v[v.size()/2]</b><br>
&#xFFFD; even number of elements, e.g. 8:<br>
0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
<b>v</b><br>
In this case we average the two middle elements (cells 3 and 4):<br>
<b>(v[v.size()/2 - 1] + v[v.size()/2])/2</b><br>
<hr>
<a name="9"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.9<br>
Computing the median<br>
We use this plan to compute the median of the sorted array:<br>
<b>// find the middle value</b><br>
<b>vector&lt;double&gt;::size_type middle = n/2;</b><br>
<b>double median;</b><br>
<b>if (n%2 == 1) // size is odd</b><br>
<b>median = v[middle];</b><br>
<b>else // size is even</b><br>
<b>median = (v[middle-1] + v[middle])/2;</b><br>
<b>cout &lt;&lt; &quot;median = &quot; &lt;&lt; median &lt;&lt; &apos;\n&apos;;</b><br>
and our program is complete.<br>
Type definitions<br>
A <b>typedef </b>declaration allows us to introduce a new name for a type:<br>
<b>typedef vector&lt;double&gt;::size_type vec_size;</b><br>
This defines a new type name <b>vec_size </b>that is equivalent to the longer name. One use is to avoid<br>repeating a long type name:<br>
<b>vec_size n = v.size();</b><br>
<b>// ...</b><br>
<b>vec_size middle = n/2;</b><br>
Vectors: further points<br>
&#xFFFD; A vector variable contains a whole vector:<br>
<b>vector&lt;int&gt; v1 = v; // copy the vector</b><br>
<b>sort(v.begin(), v.end());</b><br>
results in <b>v </b>being sorted, but <b>v1 </b>still containing a copy of the original unsorted <b>v</b>.<br>
&#xFFFD; When indexing <b>v[i]</b>, the index <b>i </b>is not checked: if it is out of range, the program may crash<br>
or continue with corrupted data.<br>
&#xFFFD; Other vector member functions:<br>
back() returns the last element of the vector<br>
pop back() removes the last element of the vector<br>
Another container: <b>deque</b><br>
Deques (double-ended queues) can be created in a similar way:<br>
<b>deque&lt;int&gt; d; // an empty deque</b><br>
Deques support indexing with <b>[]</b>, and these member functions:<br>
size() the number of elements in the deque<br>
<hr>
<a name="10"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.10<br>
<b>#include &lt;iostream&gt;</b><br>
<b>#include &lt;vector&gt;</b><br>
<b>#include &lt;algorithm&gt;</b><br>
<b>using namespace std;</b><br>
<b>int main() {</b><br>
<b>cout &lt;&lt; &quot;Please enter a series of numbers\n&quot;;</b><br>
<b>// read numbers from the standard input</b><br>
<b>// and store them in a vector</b><br>
<b>vector&lt;double&gt; v;</b><br>
<b>double x;</b><br>
<b>while (cin &gt;&gt; x)</b><br>
<b>v.push_back(x);</b><br>
<b>// compute and output results</b><br>
<b>typedef vector&lt;double&gt;::size_type vec_size;</b><br>
<b>vec_size n = v.size();</b><br>
<b>cout &lt;&lt; n &lt;&lt; &quot; numbers\n&quot;;</b><br>
<b>if (n &gt; 0) {</b><br>
<b>// sort the whole vector</b><br>
<b>sort(v.begin(), v.end());</b><br>
<b>// find the middle value</b><br>
<b>vec_size middle = n/2;</b><br>
<b>double median;</b><br>
<b>if (n%2 == 1) // size is odd</b><br>
<b>median = v[middle];</b><br>
<b>else // size is even</b><br>
<b>median = (v[middle-1] + v[middle])/2;</b><br>
<b>cout &lt;&lt; &quot;median = &quot; &lt;&lt; median &lt;&lt; &apos;\n&apos;;</b><br>
<b>}</b><br>
<b>return 0;</b><br>
<b>}</b><br>
Figure 2.2: Complete median program<br>
<hr>
<a name="11"></a>SESSION 2. SEQUENTIAL CONTAINERS<br>
2.11<br>
push back(x) add <b>x </b>to the back of the deque<br>
back() returns the last element of the deque<br>
pop back() removes the last element of the deque<br>
push front(x) add <b>x </b>to the front of the deque<br>
front() returns the first element of the deque<br>
pop front() removes the first element of the deque<br>
There are common names with <b>vector</b>, but no inheritance.<br>
Next week<br>
&#xFFFD; Functions in C++ allow us to structure and reuse code.<br>
&#xFFFD; Passing parameters by value (like in Java) involves copying, which can be expensive as in C++<br>
(unlike in Java) variables contain whole objects.<br>
&#xFFFD; Passing parameters by reference avoids copying, and is heavily used in C++.<br>
&#xFFFD; It is good practice to use <b>const </b>qualifiers to declare that you&apos;re not changing something.<br>
Exercises<br>
1. Modify the median program so that it also computes the average from the stored vector of<br>
numbers, instead of doing it while reading the numbers.<br>
2. A common scoring method in several performance competitions is to take a series of scores,<br>
ignore the highest and lowest, and average the rest. Write a program that does this by reading<br>all the values into a vector and sorting it.<br>
3. Write a program that reads some text from the standard input and just prints out the number of<br>
words in the input. (You can use the fact that <b>&lt;&lt; </b>operator on strings reads a single word.)<br>
4. Write a program that reads some text from the standard input and then prints out the longest<br>
word in the input. (You shouldn&apos;t need to retain all the words to do this.)<br>
5. Write a program that reads some text from the standard input and then prints all the words in<br>
the reverse order, one per line. (You will need to store all the words in a container.)<br>
6. (optional extra challenge) The scoring program suggested in question 2 uses O(n) space (for<br>
the vector), and takes O(n log n) time (for the sort). Can you think of an implementation that<br>takes O(1) space and O(n) time?<br>
<hr>


</p></div></body>